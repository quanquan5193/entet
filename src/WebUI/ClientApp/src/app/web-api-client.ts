/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.9.4.0 (NJsonSchema v10.3.1.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface ICardsClient {
    create(command: CreateCardCommand): Observable<number>;
    update(id: number, command: UpdateCardCommand): Observable<FileResponse>;
    get(id: number): Observable<CardDto>;
    delete(id: number): Observable<FileResponse>;
    updateItemDetails(id: number | undefined, command: UpdateCardCommand): Observable<FileResponse>;
    checkExist(memberNo: string | null | undefined): Observable<boolean>;
    importCards(file: FileParameter | null | undefined): Observable<number>;
    editCards(command: UpdateCardsCommand): Observable<boolean>;
    deleteCards(command: DeleteCardsCommand): Observable<boolean>;
    checkCardsAssigned(memberNo: string | null | undefined): Observable<boolean>;
    checkValidOldCard(memberNo: string | null | undefined): Observable<string>;
    checkValidCardForRegisterKidClubs(memberNo: string | null | undefined): Observable<string>;
    checkCardPointMigrationReceivePoint(memberNo: string | null | undefined): Observable<string>;
    checkCardPointMigrationGivePoint(memberNo: string | null | undefined, memberNoReceivePoint: string | null | undefined): Observable<string>;
    checkCardForReissueLostCard(memberNo: string | null | undefined): Observable<string>;
    checkValidNewCard(memberNo: string | null | undefined): Observable<string>;
    addCardPendingList(command: AddPendingRequestListCommand): Observable<number>;
    searchPendingListWithPagination(startCreateDate: Date | null | undefined, endCreateDate: Date | null | undefined, memberNo: string | null | undefined, requestTypeId: number | null | undefined, pICStoreId: number | null | undefined, pageNumber: number | undefined, pageSize: number | undefined, deviceId: number | undefined): Observable<PaginatedListOfPendingRequestListDto>;
    getPendingCardDetail(id: number | undefined): Observable<PendingRequestDetailDto>;
    confirmPendingCard(command: ConfirmPendingRequestCommand): Observable<boolean>;
    getListClassifyRequest(): Observable<RequestTypeDto[]>;
    checkDeleted(id: number | undefined): Observable<boolean>;
    getCardsWithPagination(sortCol: string | null | undefined, sortType: string | null | undefined, currentPage: string | null | undefined, itemPerPage: string | null | undefined, memberNo: string | null | undefined, deviceCode: string | null | undefined, expirationDate: string | null | undefined, companyCode: string | null | undefined, storeCode: string | null | undefined, status: string | null | undefined, acceptFrom: string | null | undefined, acceptTo: string | null | undefined, acceptBy: string | null | undefined): Observable<PaginatedListOfCardDto>;
    getCardsExport(memberNo: string | null | undefined, deviceCode: string | null | undefined, expirationDate: string | null | undefined, companyCode: string | null | undefined, storeCode: string | null | undefined, status: string | null | undefined, acceptFrom: string | null | undefined, acceptTo: string | null | undefined, acceptBy: string | null | undefined): Observable<FileResponse>;
    getCardsEditWithPagination(sortCol: string | null | undefined, sortType: string | null | undefined, currentPage: string | null | undefined, itemPerPage: string | null | undefined, memberNoFrom: string | null | undefined, memberNoTo: string | null | undefined, companyCode: string | null | undefined, storeCode: string | null | undefined, registeredFrom: string | null | undefined, registeredTo: string | null | undefined, registeredBy: string | null | undefined, status: string | null | undefined, expirationDate: string | null | undefined): Observable<PaginatedListOfCardDto>;
    getCardsDeleteWithPagination(sortCol: string | null | undefined, sortType: string | null | undefined, currentPage: string | null | undefined, itemPerPage: string | null | undefined, memberNoFrom: string | null | undefined, memberNoTo: string | null | undefined, companyCode: string | null | undefined, storeCode: string | null | undefined, registeredFrom: string | null | undefined, registeredTo: string | null | undefined, registeredBy: string | null | undefined, status: string | null | undefined, expirationDate: string | null | undefined): Observable<PaginatedListOfCardDto>;
    addMigrateRequest(command: AddMigrateRequestCommand): Observable<number>;
    searchPrepaidCard(customerNo: string | null | undefined, requestType: number | null | undefined, pICStoreId: number | null | undefined, startDate: Date | null | undefined, endDate: Date | null | undefined, orderBy: string | null | undefined, orderType: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined, deviceId: number | undefined): Observable<PaginatedListOfPrepaidCardDto>;
    getPrepaidCardDetail(id: number | undefined): Observable<PrepaidCardDetailDto>;
}

@Injectable({
    providedIn: 'root'
})
export class CardsClient implements ICardsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    create(command: CreateCardCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Cards";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    update(id: number, command: UpdateCardCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Cards/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    get(id: number): Observable<CardDto> {
        let url_ = this.baseUrl + "/api/Cards/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<CardDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<CardDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CardDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardDto>(<any>null);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Cards/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    updateItemDetails(id: number | undefined, command: UpdateCardCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Cards/UpdateItemDetails?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateItemDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateItemDetails(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateItemDetails(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    checkExist(memberNo: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Cards/CheckExist?";
        if (memberNo !== undefined && memberNo !== null)
            url_ += "memberNo=" + encodeURIComponent("" + memberNo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckExist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckExist(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processCheckExist(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    importCards(file: FileParameter | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/Cards/ImportCards";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("File", file.data, file.fileName ? file.fileName : "File");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportCards(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportCards(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processImportCards(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    editCards(command: UpdateCardsCommand): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Cards/EditCards";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditCards(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditCards(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processEditCards(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    deleteCards(command: DeleteCardsCommand): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Cards/DeleteCards";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCards(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCards(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteCards(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    checkCardsAssigned(memberNo: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Cards/CheckCardsAssigned?";
        if (memberNo !== undefined && memberNo !== null)
            url_ += "memberNo=" + encodeURIComponent("" + memberNo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckCardsAssigned(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckCardsAssigned(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processCheckCardsAssigned(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    checkValidOldCard(memberNo: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/Cards/CheckValidOldCard?";
        if (memberNo !== undefined && memberNo !== null)
            url_ += "memberNo=" + encodeURIComponent("" + memberNo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckValidOldCard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckValidOldCard(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processCheckValidOldCard(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    checkValidCardForRegisterKidClubs(memberNo: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/Cards/CheckValidCardForRegisterKidClubs?";
        if (memberNo !== undefined && memberNo !== null)
            url_ += "memberNo=" + encodeURIComponent("" + memberNo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckValidCardForRegisterKidClubs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckValidCardForRegisterKidClubs(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processCheckValidCardForRegisterKidClubs(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    checkCardPointMigrationReceivePoint(memberNo: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/Cards/CheckCardPointMigrationReceivePoint?";
        if (memberNo !== undefined && memberNo !== null)
            url_ += "memberNo=" + encodeURIComponent("" + memberNo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckCardPointMigrationReceivePoint(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckCardPointMigrationReceivePoint(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processCheckCardPointMigrationReceivePoint(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    checkCardPointMigrationGivePoint(memberNo: string | null | undefined, memberNoReceivePoint: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/Cards/CheckCardPointMigrationGivePoint?";
        if (memberNo !== undefined && memberNo !== null)
            url_ += "memberNo=" + encodeURIComponent("" + memberNo) + "&";
        if (memberNoReceivePoint !== undefined && memberNoReceivePoint !== null)
            url_ += "memberNoReceivePoint=" + encodeURIComponent("" + memberNoReceivePoint) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckCardPointMigrationGivePoint(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckCardPointMigrationGivePoint(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processCheckCardPointMigrationGivePoint(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    checkCardForReissueLostCard(memberNo: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/Cards/CheckCardForReissueLostCard?";
        if (memberNo !== undefined && memberNo !== null)
            url_ += "memberNo=" + encodeURIComponent("" + memberNo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckCardForReissueLostCard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckCardForReissueLostCard(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processCheckCardForReissueLostCard(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    checkValidNewCard(memberNo: string | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/Cards/CheckValidNewCard?";
        if (memberNo !== undefined && memberNo !== null)
            url_ += "memberNo=" + encodeURIComponent("" + memberNo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckValidNewCard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckValidNewCard(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processCheckValidNewCard(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    addCardPendingList(command: AddPendingRequestListCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Cards/AddCardPendingList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddCardPendingList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddCardPendingList(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processAddCardPendingList(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    searchPendingListWithPagination(startCreateDate: Date | null | undefined, endCreateDate: Date | null | undefined, memberNo: string | null | undefined, requestTypeId: number | null | undefined, pICStoreId: number | null | undefined, pageNumber: number | undefined, pageSize: number | undefined, deviceId: number | undefined): Observable<PaginatedListOfPendingRequestListDto> {
        let url_ = this.baseUrl + "/api/Cards/SearchPendingListWithPagination?";
        if (startCreateDate !== undefined && startCreateDate !== null)
            url_ += "StartCreateDate=" + encodeURIComponent(startCreateDate ? "" + startCreateDate.toJSON() : "") + "&";
        if (endCreateDate !== undefined && endCreateDate !== null)
            url_ += "EndCreateDate=" + encodeURIComponent(endCreateDate ? "" + endCreateDate.toJSON() : "") + "&";
        if (memberNo !== undefined && memberNo !== null)
            url_ += "MemberNo=" + encodeURIComponent("" + memberNo) + "&";
        if (requestTypeId !== undefined && requestTypeId !== null)
            url_ += "RequestTypeId=" + encodeURIComponent("" + requestTypeId) + "&";
        if (pICStoreId !== undefined && pICStoreId !== null)
            url_ += "PICStoreId=" + encodeURIComponent("" + pICStoreId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (deviceId === null)
            throw new Error("The parameter 'deviceId' cannot be null.");
        else if (deviceId !== undefined)
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchPendingListWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchPendingListWithPagination(<any>response_);
                } catch (e) {
                    return <Observable<PaginatedListOfPendingRequestListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaginatedListOfPendingRequestListDto>><any>_observableThrow(response_);
        }));
    }

    protected processSearchPendingListWithPagination(response: HttpResponseBase): Observable<PaginatedListOfPendingRequestListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfPendingRequestListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListOfPendingRequestListDto>(<any>null);
    }

    getPendingCardDetail(id: number | undefined): Observable<PendingRequestDetailDto> {
        let url_ = this.baseUrl + "/api/Cards/GetPendingCardDetail?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPendingCardDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPendingCardDetail(<any>response_);
                } catch (e) {
                    return <Observable<PendingRequestDetailDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PendingRequestDetailDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPendingCardDetail(response: HttpResponseBase): Observable<PendingRequestDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PendingRequestDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PendingRequestDetailDto>(<any>null);
    }

    confirmPendingCard(command: ConfirmPendingRequestCommand): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Cards/ConfirmPendingCard";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmPendingCard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmPendingCard(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processConfirmPendingCard(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    getListClassifyRequest(): Observable<RequestTypeDto[]> {
        let url_ = this.baseUrl + "/api/Cards/GetListClassifyRequest";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListClassifyRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListClassifyRequest(<any>response_);
                } catch (e) {
                    return <Observable<RequestTypeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestTypeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetListClassifyRequest(response: HttpResponseBase): Observable<RequestTypeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RequestTypeDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestTypeDto[]>(<any>null);
    }

    checkDeleted(id: number | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Cards/CheckDeleted?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckDeleted(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckDeleted(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processCheckDeleted(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    getCardsWithPagination(sortCol: string | null | undefined, sortType: string | null | undefined, currentPage: string | null | undefined, itemPerPage: string | null | undefined, memberNo: string | null | undefined, deviceCode: string | null | undefined, expirationDate: string | null | undefined, companyCode: string | null | undefined, storeCode: string | null | undefined, status: string | null | undefined, acceptFrom: string | null | undefined, acceptTo: string | null | undefined, acceptBy: string | null | undefined): Observable<PaginatedListOfCardDto> {
        let url_ = this.baseUrl + "/api/Cards/GetCardsWithPagination?";
        if (sortCol !== undefined && sortCol !== null)
            url_ += "sortCol=" + encodeURIComponent("" + sortCol) + "&";
        if (sortType !== undefined && sortType !== null)
            url_ += "sortType=" + encodeURIComponent("" + sortType) + "&";
        if (currentPage !== undefined && currentPage !== null)
            url_ += "currentPage=" + encodeURIComponent("" + currentPage) + "&";
        if (itemPerPage !== undefined && itemPerPage !== null)
            url_ += "itemPerPage=" + encodeURIComponent("" + itemPerPage) + "&";
        if (memberNo !== undefined && memberNo !== null)
            url_ += "memberNo=" + encodeURIComponent("" + memberNo) + "&";
        if (deviceCode !== undefined && deviceCode !== null)
            url_ += "deviceCode=" + encodeURIComponent("" + deviceCode) + "&";
        if (expirationDate !== undefined && expirationDate !== null)
            url_ += "expirationDate=" + encodeURIComponent("" + expirationDate) + "&";
        if (companyCode !== undefined && companyCode !== null)
            url_ += "companyCode=" + encodeURIComponent("" + companyCode) + "&";
        if (storeCode !== undefined && storeCode !== null)
            url_ += "storeCode=" + encodeURIComponent("" + storeCode) + "&";
        if (status !== undefined && status !== null)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        if (acceptFrom !== undefined && acceptFrom !== null)
            url_ += "acceptFrom=" + encodeURIComponent("" + acceptFrom) + "&";
        if (acceptTo !== undefined && acceptTo !== null)
            url_ += "acceptTo=" + encodeURIComponent("" + acceptTo) + "&";
        if (acceptBy !== undefined && acceptBy !== null)
            url_ += "acceptBy=" + encodeURIComponent("" + acceptBy) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCardsWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCardsWithPagination(<any>response_);
                } catch (e) {
                    return <Observable<PaginatedListOfCardDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaginatedListOfCardDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCardsWithPagination(response: HttpResponseBase): Observable<PaginatedListOfCardDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfCardDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListOfCardDto>(<any>null);
    }

    getCardsExport(memberNo: string | null | undefined, deviceCode: string | null | undefined, expirationDate: string | null | undefined, companyCode: string | null | undefined, storeCode: string | null | undefined, status: string | null | undefined, acceptFrom: string | null | undefined, acceptTo: string | null | undefined, acceptBy: string | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Cards/GetCardsExport?";
        if (memberNo !== undefined && memberNo !== null)
            url_ += "memberNo=" + encodeURIComponent("" + memberNo) + "&";
        if (deviceCode !== undefined && deviceCode !== null)
            url_ += "deviceCode=" + encodeURIComponent("" + deviceCode) + "&";
        if (expirationDate !== undefined && expirationDate !== null)
            url_ += "expirationDate=" + encodeURIComponent("" + expirationDate) + "&";
        if (companyCode !== undefined && companyCode !== null)
            url_ += "companyCode=" + encodeURIComponent("" + companyCode) + "&";
        if (storeCode !== undefined && storeCode !== null)
            url_ += "storeCode=" + encodeURIComponent("" + storeCode) + "&";
        if (status !== undefined && status !== null)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        if (acceptFrom !== undefined && acceptFrom !== null)
            url_ += "acceptFrom=" + encodeURIComponent("" + acceptFrom) + "&";
        if (acceptTo !== undefined && acceptTo !== null)
            url_ += "acceptTo=" + encodeURIComponent("" + acceptTo) + "&";
        if (acceptBy !== undefined && acceptBy !== null)
            url_ += "acceptBy=" + encodeURIComponent("" + acceptBy) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCardsExport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCardsExport(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetCardsExport(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getCardsEditWithPagination(sortCol: string | null | undefined, sortType: string | null | undefined, currentPage: string | null | undefined, itemPerPage: string | null | undefined, memberNoFrom: string | null | undefined, memberNoTo: string | null | undefined, companyCode: string | null | undefined, storeCode: string | null | undefined, registeredFrom: string | null | undefined, registeredTo: string | null | undefined, registeredBy: string | null | undefined, status: string | null | undefined, expirationDate: string | null | undefined): Observable<PaginatedListOfCardDto> {
        let url_ = this.baseUrl + "/api/Cards/GetCardsEditWithPagination?";
        if (sortCol !== undefined && sortCol !== null)
            url_ += "sortCol=" + encodeURIComponent("" + sortCol) + "&";
        if (sortType !== undefined && sortType !== null)
            url_ += "sortType=" + encodeURIComponent("" + sortType) + "&";
        if (currentPage !== undefined && currentPage !== null)
            url_ += "currentPage=" + encodeURIComponent("" + currentPage) + "&";
        if (itemPerPage !== undefined && itemPerPage !== null)
            url_ += "itemPerPage=" + encodeURIComponent("" + itemPerPage) + "&";
        if (memberNoFrom !== undefined && memberNoFrom !== null)
            url_ += "memberNoFrom=" + encodeURIComponent("" + memberNoFrom) + "&";
        if (memberNoTo !== undefined && memberNoTo !== null)
            url_ += "memberNoTo=" + encodeURIComponent("" + memberNoTo) + "&";
        if (companyCode !== undefined && companyCode !== null)
            url_ += "companyCode=" + encodeURIComponent("" + companyCode) + "&";
        if (storeCode !== undefined && storeCode !== null)
            url_ += "storeCode=" + encodeURIComponent("" + storeCode) + "&";
        if (registeredFrom !== undefined && registeredFrom !== null)
            url_ += "registeredFrom=" + encodeURIComponent("" + registeredFrom) + "&";
        if (registeredTo !== undefined && registeredTo !== null)
            url_ += "registeredTo=" + encodeURIComponent("" + registeredTo) + "&";
        if (registeredBy !== undefined && registeredBy !== null)
            url_ += "registeredBy=" + encodeURIComponent("" + registeredBy) + "&";
        if (status !== undefined && status !== null)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        if (expirationDate !== undefined && expirationDate !== null)
            url_ += "expirationDate=" + encodeURIComponent("" + expirationDate) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCardsEditWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCardsEditWithPagination(<any>response_);
                } catch (e) {
                    return <Observable<PaginatedListOfCardDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaginatedListOfCardDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCardsEditWithPagination(response: HttpResponseBase): Observable<PaginatedListOfCardDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfCardDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListOfCardDto>(<any>null);
    }

    getCardsDeleteWithPagination(sortCol: string | null | undefined, sortType: string | null | undefined, currentPage: string | null | undefined, itemPerPage: string | null | undefined, memberNoFrom: string | null | undefined, memberNoTo: string | null | undefined, companyCode: string | null | undefined, storeCode: string | null | undefined, registeredFrom: string | null | undefined, registeredTo: string | null | undefined, registeredBy: string | null | undefined, status: string | null | undefined, expirationDate: string | null | undefined): Observable<PaginatedListOfCardDto> {
        let url_ = this.baseUrl + "/api/Cards/GetCardsDeleteWithPagination?";
        if (sortCol !== undefined && sortCol !== null)
            url_ += "sortCol=" + encodeURIComponent("" + sortCol) + "&";
        if (sortType !== undefined && sortType !== null)
            url_ += "sortType=" + encodeURIComponent("" + sortType) + "&";
        if (currentPage !== undefined && currentPage !== null)
            url_ += "currentPage=" + encodeURIComponent("" + currentPage) + "&";
        if (itemPerPage !== undefined && itemPerPage !== null)
            url_ += "itemPerPage=" + encodeURIComponent("" + itemPerPage) + "&";
        if (memberNoFrom !== undefined && memberNoFrom !== null)
            url_ += "memberNoFrom=" + encodeURIComponent("" + memberNoFrom) + "&";
        if (memberNoTo !== undefined && memberNoTo !== null)
            url_ += "memberNoTo=" + encodeURIComponent("" + memberNoTo) + "&";
        if (companyCode !== undefined && companyCode !== null)
            url_ += "companyCode=" + encodeURIComponent("" + companyCode) + "&";
        if (storeCode !== undefined && storeCode !== null)
            url_ += "storeCode=" + encodeURIComponent("" + storeCode) + "&";
        if (registeredFrom !== undefined && registeredFrom !== null)
            url_ += "registeredFrom=" + encodeURIComponent("" + registeredFrom) + "&";
        if (registeredTo !== undefined && registeredTo !== null)
            url_ += "registeredTo=" + encodeURIComponent("" + registeredTo) + "&";
        if (registeredBy !== undefined && registeredBy !== null)
            url_ += "registeredBy=" + encodeURIComponent("" + registeredBy) + "&";
        if (status !== undefined && status !== null)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        if (expirationDate !== undefined && expirationDate !== null)
            url_ += "expirationDate=" + encodeURIComponent("" + expirationDate) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCardsDeleteWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCardsDeleteWithPagination(<any>response_);
                } catch (e) {
                    return <Observable<PaginatedListOfCardDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaginatedListOfCardDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCardsDeleteWithPagination(response: HttpResponseBase): Observable<PaginatedListOfCardDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfCardDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListOfCardDto>(<any>null);
    }

    addMigrateRequest(command: AddMigrateRequestCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Cards/AddMigrateRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddMigrateRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddMigrateRequest(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processAddMigrateRequest(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    searchPrepaidCard(customerNo: string | null | undefined, requestType: number | null | undefined, pICStoreId: number | null | undefined, startDate: Date | null | undefined, endDate: Date | null | undefined, orderBy: string | null | undefined, orderType: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined, deviceId: number | undefined): Observable<PaginatedListOfPrepaidCardDto> {
        let url_ = this.baseUrl + "/api/Cards/SearchPrepaidCard?";
        if (customerNo !== undefined && customerNo !== null)
            url_ += "CustomerNo=" + encodeURIComponent("" + customerNo) + "&";
        if (requestType !== undefined && requestType !== null)
            url_ += "RequestType=" + encodeURIComponent("" + requestType) + "&";
        if (pICStoreId !== undefined && pICStoreId !== null)
            url_ += "PICStoreId=" + encodeURIComponent("" + pICStoreId) + "&";
        if (startDate !== undefined && startDate !== null)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate !== undefined && endDate !== null)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        if (orderBy !== undefined && orderBy !== null)
            url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
        if (orderType !== undefined && orderType !== null)
            url_ += "OrderType=" + encodeURIComponent("" + orderType) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (deviceId === null)
            throw new Error("The parameter 'deviceId' cannot be null.");
        else if (deviceId !== undefined)
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchPrepaidCard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchPrepaidCard(<any>response_);
                } catch (e) {
                    return <Observable<PaginatedListOfPrepaidCardDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaginatedListOfPrepaidCardDto>><any>_observableThrow(response_);
        }));
    }

    protected processSearchPrepaidCard(response: HttpResponseBase): Observable<PaginatedListOfPrepaidCardDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfPrepaidCardDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListOfPrepaidCardDto>(<any>null);
    }

    getPrepaidCardDetail(id: number | undefined): Observable<PrepaidCardDetailDto> {
        let url_ = this.baseUrl + "/api/Cards/GetPrepaidCardDetail?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPrepaidCardDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPrepaidCardDetail(<any>response_);
                } catch (e) {
                    return <Observable<PrepaidCardDetailDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PrepaidCardDetailDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPrepaidCardDetail(response: HttpResponseBase): Observable<PrepaidCardDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PrepaidCardDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PrepaidCardDetailDto>(<any>null);
    }
}

export interface ICompaniesClient {
    getCompaniesWithPagination(companyCode: string | null | undefined, companyName: string | null | undefined, orderBy: string | null | undefined, orderType: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfCompanyDto>;
    create(command: CreateCompanyCommand): Observable<number>;
    getCompanies(): Observable<CompaniesVm>;
    update(id: number, command: UpdateCompanyCommand): Observable<FileResponse>;
    delete(id: number, command: DeleteCompanyCommand): Observable<FileResponse>;
    updateItemDetails(id: number | undefined, command: UpdateCompanyCommand): Observable<FileResponse>;
    getDetailCompanyCommand(id: number | undefined): Observable<GetDetailCompanyDto>;
    getDetailCompanyWithCodeCommand(companyCode: string | null | undefined): Observable<GetDetailCompanyWithCodeDto>;
}

@Injectable({
    providedIn: 'root'
})
export class CompaniesClient implements ICompaniesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getCompaniesWithPagination(companyCode: string | null | undefined, companyName: string | null | undefined, orderBy: string | null | undefined, orderType: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfCompanyDto> {
        let url_ = this.baseUrl + "/api/Companies?";
        if (companyCode !== undefined && companyCode !== null)
            url_ += "CompanyCode=" + encodeURIComponent("" + companyCode) + "&";
        if (companyName !== undefined && companyName !== null)
            url_ += "CompanyName=" + encodeURIComponent("" + companyName) + "&";
        if (orderBy !== undefined && orderBy !== null)
            url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
        if (orderType !== undefined && orderType !== null)
            url_ += "OrderType=" + encodeURIComponent("" + orderType) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCompaniesWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCompaniesWithPagination(<any>response_);
                } catch (e) {
                    return <Observable<PaginatedListOfCompanyDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaginatedListOfCompanyDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCompaniesWithPagination(response: HttpResponseBase): Observable<PaginatedListOfCompanyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfCompanyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListOfCompanyDto>(<any>null);
    }

    create(command: CreateCompanyCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Companies";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    getCompanies(): Observable<CompaniesVm> {
        let url_ = this.baseUrl + "/api/Companies/GetCompanies";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCompanies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCompanies(<any>response_);
                } catch (e) {
                    return <Observable<CompaniesVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<CompaniesVm>><any>_observableThrow(response_);
        }));
    }

    protected processGetCompanies(response: HttpResponseBase): Observable<CompaniesVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompaniesVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompaniesVm>(<any>null);
    }

    update(id: number, command: UpdateCompanyCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Companies/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    delete(id: number, command: DeleteCompanyCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Companies/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    updateItemDetails(id: number | undefined, command: UpdateCompanyCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Companies/UpdateItemDetails?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateItemDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateItemDetails(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateItemDetails(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getDetailCompanyCommand(id: number | undefined): Observable<GetDetailCompanyDto> {
        let url_ = this.baseUrl + "/api/Companies/GetDetailCompanyCommand?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDetailCompanyCommand(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetailCompanyCommand(<any>response_);
                } catch (e) {
                    return <Observable<GetDetailCompanyDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDetailCompanyDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDetailCompanyCommand(response: HttpResponseBase): Observable<GetDetailCompanyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetDetailCompanyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDetailCompanyDto>(<any>null);
    }

    getDetailCompanyWithCodeCommand(companyCode: string | null | undefined): Observable<GetDetailCompanyWithCodeDto> {
        let url_ = this.baseUrl + "/api/Companies/GetDetailCompanyWithCodeCommand?";
        if (companyCode !== undefined && companyCode !== null)
            url_ += "CompanyCode=" + encodeURIComponent("" + companyCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDetailCompanyWithCodeCommand(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDetailCompanyWithCodeCommand(<any>response_);
                } catch (e) {
                    return <Observable<GetDetailCompanyWithCodeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDetailCompanyWithCodeDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDetailCompanyWithCodeCommand(response: HttpResponseBase): Observable<GetDetailCompanyWithCodeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetDetailCompanyWithCodeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDetailCompanyWithCodeDto>(<any>null);
    }
}

export interface IDevicesClient {
    searchDevicesWithPagination(companyCode: string | null | undefined, companyName: string | null | undefined, deviceCode: string | null | undefined, orderBy: string | null | undefined, orderType: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfSearchDevicesWithPaginationDto>;
    getDevice(id: number | undefined): Observable<GetDeviceDto>;
    updateDevice(id: number | undefined, companyCode: string | null | undefined, storeCode: string | null | undefined, deviceStatus: boolean | undefined, isAutoLock: boolean | undefined, lat: string | null | undefined, long: string | null | undefined, updatedAt: Date | null | undefined): Observable<boolean>;
    createDevice(command: CreateDeviceCommand): Observable<number>;
    deleteDevice(id: number): Observable<boolean>;
    update(id: number, command: UpdateDeviceMobileCommand): Observable<FileResponse>;
    getDeviceById(storeId: number | undefined, id: number | undefined): Observable<DeviceDto>;
    getDeviceByCode(storeId: number | undefined, code: string | null | undefined): Observable<DeviceDto>;
}

@Injectable({
    providedIn: 'root'
})
export class DevicesClient implements IDevicesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    searchDevicesWithPagination(companyCode: string | null | undefined, companyName: string | null | undefined, deviceCode: string | null | undefined, orderBy: string | null | undefined, orderType: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfSearchDevicesWithPaginationDto> {
        let url_ = this.baseUrl + "/api/Devices/SearchDevicesWithPagination?";
        if (companyCode !== undefined && companyCode !== null)
            url_ += "CompanyCode=" + encodeURIComponent("" + companyCode) + "&";
        if (companyName !== undefined && companyName !== null)
            url_ += "CompanyName=" + encodeURIComponent("" + companyName) + "&";
        if (deviceCode !== undefined && deviceCode !== null)
            url_ += "DeviceCode=" + encodeURIComponent("" + deviceCode) + "&";
        if (orderBy !== undefined && orderBy !== null)
            url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
        if (orderType !== undefined && orderType !== null)
            url_ += "OrderType=" + encodeURIComponent("" + orderType) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchDevicesWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchDevicesWithPagination(<any>response_);
                } catch (e) {
                    return <Observable<PaginatedListOfSearchDevicesWithPaginationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaginatedListOfSearchDevicesWithPaginationDto>><any>_observableThrow(response_);
        }));
    }

    protected processSearchDevicesWithPagination(response: HttpResponseBase): Observable<PaginatedListOfSearchDevicesWithPaginationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfSearchDevicesWithPaginationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListOfSearchDevicesWithPaginationDto>(<any>null);
    }

    getDevice(id: number | undefined): Observable<GetDeviceDto> {
        let url_ = this.baseUrl + "/api/Devices?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDevice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDevice(<any>response_);
                } catch (e) {
                    return <Observable<GetDeviceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDeviceDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDevice(response: HttpResponseBase): Observable<GetDeviceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetDeviceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDeviceDto>(<any>null);
    }

    updateDevice(id: number | undefined, companyCode: string | null | undefined, storeCode: string | null | undefined, deviceStatus: boolean | undefined, isAutoLock: boolean | undefined, lat: string | null | undefined, long: string | null | undefined, updatedAt: Date | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Devices?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (companyCode !== undefined && companyCode !== null)
            url_ += "CompanyCode=" + encodeURIComponent("" + companyCode) + "&";
        if (storeCode !== undefined && storeCode !== null)
            url_ += "StoreCode=" + encodeURIComponent("" + storeCode) + "&";
        if (deviceStatus === null)
            throw new Error("The parameter 'deviceStatus' cannot be null.");
        else if (deviceStatus !== undefined)
            url_ += "DeviceStatus=" + encodeURIComponent("" + deviceStatus) + "&";
        if (isAutoLock === null)
            throw new Error("The parameter 'isAutoLock' cannot be null.");
        else if (isAutoLock !== undefined)
            url_ += "IsAutoLock=" + encodeURIComponent("" + isAutoLock) + "&";
        if (lat !== undefined && lat !== null)
            url_ += "Lat=" + encodeURIComponent("" + lat) + "&";
        if (long !== undefined && long !== null)
            url_ += "Long=" + encodeURIComponent("" + long) + "&";
        if (updatedAt !== undefined && updatedAt !== null)
            url_ += "UpdatedAt=" + encodeURIComponent(updatedAt ? "" + updatedAt.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDevice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDevice(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateDevice(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    createDevice(command: CreateDeviceCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Devices";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateDevice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateDevice(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateDevice(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    deleteDevice(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Devices/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDevice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDevice(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteDevice(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    update(id: number, command: UpdateDeviceMobileCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Devices/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getDeviceById(storeId: number | undefined, id: number | undefined): Observable<DeviceDto> {
        let url_ = this.baseUrl + "/api/Devices/GetDeviceById?";
        if (storeId === null)
            throw new Error("The parameter 'storeId' cannot be null.");
        else if (storeId !== undefined)
            url_ += "StoreId=" + encodeURIComponent("" + storeId) + "&";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceById(<any>response_);
                } catch (e) {
                    return <Observable<DeviceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DeviceDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeviceById(response: HttpResponseBase): Observable<DeviceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeviceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeviceDto>(<any>null);
    }

    getDeviceByCode(storeId: number | undefined, code: string | null | undefined): Observable<DeviceDto> {
        let url_ = this.baseUrl + "/api/Devices/GetDeviceByCode?";
        if (storeId === null)
            throw new Error("The parameter 'storeId' cannot be null.");
        else if (storeId !== undefined)
            url_ += "StoreId=" + encodeURIComponent("" + storeId) + "&";
        if (code !== undefined && code !== null)
            url_ += "Code=" + encodeURIComponent("" + code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDeviceByCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeviceByCode(<any>response_);
                } catch (e) {
                    return <Observable<DeviceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DeviceDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDeviceByCode(response: HttpResponseBase): Observable<DeviceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeviceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeviceDto>(<any>null);
    }
}

export interface IKidsClubClient {
    getPaging(memberNo: string | null | undefined, kidName: string | null | undefined, companyCode: string | null | undefined, storeCode: string | null | undefined, deviceNumber: string | null | undefined, registerDateFrom: Date | null | undefined, registerDateTo: Date | null | undefined, pICStoreName: string | null | undefined, page: number | undefined, size: number | undefined, sortBy: string | null | undefined, sortDimension: string | null | undefined): Observable<PaginatedListOfKidDto>;
    updateKid(command: UpdateKidCommand): Observable<UpdateKidResultDto>;
    getKid(id: number): Observable<KidDetailDto>;
    deleteKid(id: number): Observable<boolean>;
    exportKids(memberNo: string | null | undefined, kidName: string | null | undefined, companyCode: string | null | undefined, storeCode: string | null | undefined, deviceNumber: string | null | undefined, registerDateFrom: Date | null | undefined, registerDateTo: Date | null | undefined, pICStoreName: string | null | undefined, sortBy: string | null | undefined, sortDimension: string | null | undefined): Observable<FileResponse>;
    getKidsDeleteWithPagination(pageNumber: number | undefined, pageSize: number | undefined, sortType: string | null | undefined, sortBy: string | null | undefined, companyCode: string | null | undefined, storeCode: string | null | undefined, deviceCode: string | null | undefined, registeredFrom: string | null | undefined, registeredTo: string | null | undefined): Observable<PaginatedListOfMemberKidDeleteDto>;
    deleteMemberKids(command: DeleteKidsCommand): Observable<boolean>;
}

@Injectable({
    providedIn: 'root'
})
export class KidsClubClient implements IKidsClubClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getPaging(memberNo: string | null | undefined, kidName: string | null | undefined, companyCode: string | null | undefined, storeCode: string | null | undefined, deviceNumber: string | null | undefined, registerDateFrom: Date | null | undefined, registerDateTo: Date | null | undefined, pICStoreName: string | null | undefined, page: number | undefined, size: number | undefined, sortBy: string | null | undefined, sortDimension: string | null | undefined): Observable<PaginatedListOfKidDto> {
        let url_ = this.baseUrl + "/api/KidsClub?";
        if (memberNo !== undefined && memberNo !== null)
            url_ += "MemberNo=" + encodeURIComponent("" + memberNo) + "&";
        if (kidName !== undefined && kidName !== null)
            url_ += "KidName=" + encodeURIComponent("" + kidName) + "&";
        if (companyCode !== undefined && companyCode !== null)
            url_ += "CompanyCode=" + encodeURIComponent("" + companyCode) + "&";
        if (storeCode !== undefined && storeCode !== null)
            url_ += "StoreCode=" + encodeURIComponent("" + storeCode) + "&";
        if (deviceNumber !== undefined && deviceNumber !== null)
            url_ += "DeviceNumber=" + encodeURIComponent("" + deviceNumber) + "&";
        if (registerDateFrom !== undefined && registerDateFrom !== null)
            url_ += "RegisterDateFrom=" + encodeURIComponent(registerDateFrom ? "" + registerDateFrom.toJSON() : "") + "&";
        if (registerDateTo !== undefined && registerDateTo !== null)
            url_ += "RegisterDateTo=" + encodeURIComponent(registerDateTo ? "" + registerDateTo.toJSON() : "") + "&";
        if (pICStoreName !== undefined && pICStoreName !== null)
            url_ += "PICStoreName=" + encodeURIComponent("" + pICStoreName) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDimension !== undefined && sortDimension !== null)
            url_ += "SortDimension=" + encodeURIComponent("" + sortDimension) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaging(<any>response_);
                } catch (e) {
                    return <Observable<PaginatedListOfKidDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaginatedListOfKidDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaging(response: HttpResponseBase): Observable<PaginatedListOfKidDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfKidDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListOfKidDto>(<any>null);
    }

    updateKid(command: UpdateKidCommand): Observable<UpdateKidResultDto> {
        let url_ = this.baseUrl + "/api/KidsClub";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateKid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateKid(<any>response_);
                } catch (e) {
                    return <Observable<UpdateKidResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UpdateKidResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateKid(response: HttpResponseBase): Observable<UpdateKidResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateKidResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateKidResultDto>(<any>null);
    }

    getKid(id: number): Observable<KidDetailDto> {
        let url_ = this.baseUrl + "/api/KidsClub/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetKid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetKid(<any>response_);
                } catch (e) {
                    return <Observable<KidDetailDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<KidDetailDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetKid(response: HttpResponseBase): Observable<KidDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = KidDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<KidDetailDto>(<any>null);
    }

    deleteKid(id: number): Observable<boolean> {
        let url_ = this.baseUrl + "/api/KidsClub/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteKid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteKid(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteKid(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    exportKids(memberNo: string | null | undefined, kidName: string | null | undefined, companyCode: string | null | undefined, storeCode: string | null | undefined, deviceNumber: string | null | undefined, registerDateFrom: Date | null | undefined, registerDateTo: Date | null | undefined, pICStoreName: string | null | undefined, sortBy: string | null | undefined, sortDimension: string | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/KidsClub/ExportKids?";
        if (memberNo !== undefined && memberNo !== null)
            url_ += "MemberNo=" + encodeURIComponent("" + memberNo) + "&";
        if (kidName !== undefined && kidName !== null)
            url_ += "KidName=" + encodeURIComponent("" + kidName) + "&";
        if (companyCode !== undefined && companyCode !== null)
            url_ += "CompanyCode=" + encodeURIComponent("" + companyCode) + "&";
        if (storeCode !== undefined && storeCode !== null)
            url_ += "StoreCode=" + encodeURIComponent("" + storeCode) + "&";
        if (deviceNumber !== undefined && deviceNumber !== null)
            url_ += "DeviceNumber=" + encodeURIComponent("" + deviceNumber) + "&";
        if (registerDateFrom !== undefined && registerDateFrom !== null)
            url_ += "RegisterDateFrom=" + encodeURIComponent(registerDateFrom ? "" + registerDateFrom.toJSON() : "") + "&";
        if (registerDateTo !== undefined && registerDateTo !== null)
            url_ += "RegisterDateTo=" + encodeURIComponent(registerDateTo ? "" + registerDateTo.toJSON() : "") + "&";
        if (pICStoreName !== undefined && pICStoreName !== null)
            url_ += "PICStoreName=" + encodeURIComponent("" + pICStoreName) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDimension !== undefined && sortDimension !== null)
            url_ += "SortDimension=" + encodeURIComponent("" + sortDimension) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportKids(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportKids(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processExportKids(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getKidsDeleteWithPagination(pageNumber: number | undefined, pageSize: number | undefined, sortType: string | null | undefined, sortBy: string | null | undefined, companyCode: string | null | undefined, storeCode: string | null | undefined, deviceCode: string | null | undefined, registeredFrom: string | null | undefined, registeredTo: string | null | undefined): Observable<PaginatedListOfMemberKidDeleteDto> {
        let url_ = this.baseUrl + "/api/KidsClub/GetKidsDeleteWithPagination?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortType !== undefined && sortType !== null)
            url_ += "SortType=" + encodeURIComponent("" + sortType) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (companyCode !== undefined && companyCode !== null)
            url_ += "CompanyCode=" + encodeURIComponent("" + companyCode) + "&";
        if (storeCode !== undefined && storeCode !== null)
            url_ += "StoreCode=" + encodeURIComponent("" + storeCode) + "&";
        if (deviceCode !== undefined && deviceCode !== null)
            url_ += "DeviceCode=" + encodeURIComponent("" + deviceCode) + "&";
        if (registeredFrom !== undefined && registeredFrom !== null)
            url_ += "RegisteredFrom=" + encodeURIComponent("" + registeredFrom) + "&";
        if (registeredTo !== undefined && registeredTo !== null)
            url_ += "RegisteredTo=" + encodeURIComponent("" + registeredTo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetKidsDeleteWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetKidsDeleteWithPagination(<any>response_);
                } catch (e) {
                    return <Observable<PaginatedListOfMemberKidDeleteDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaginatedListOfMemberKidDeleteDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetKidsDeleteWithPagination(response: HttpResponseBase): Observable<PaginatedListOfMemberKidDeleteDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfMemberKidDeleteDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListOfMemberKidDeleteDto>(<any>null);
    }

    deleteMemberKids(command: DeleteKidsCommand): Observable<boolean> {
        let url_ = this.baseUrl + "/api/KidsClub/DeleteMemberKids";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMemberKids(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMemberKids(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteMemberKids(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

export interface ILoginClient {
    create(query: GetTokenQuery): Observable<LoginResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class LoginClient implements ILoginClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    create(query: GetTokenQuery): Observable<LoginResponse> {
        let url_ = this.baseUrl + "/api/Login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<LoginResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoginResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<LoginResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoginResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoginResponse>(<any>null);
    }
}

export interface IMembersClient {
    create(command: RegisterMemberCommand): Observable<number>;
    getCardsWithMemberNo(memberNo: string | null | undefined): Observable<MemberInfoDto>;
    importZipCode(): Observable<boolean>;
    validateCardForRegister(memberNo: string | null | undefined): Observable<CardValidationDto>;
    getInfoZipcode(zipcode: string | null | undefined): Observable<ZipcodeDto>;
    updateMember(command: UpdateMemberCommand): Observable<number>;
    updateMemberNo(command: UpdateMemberNoCommand): Observable<number>;
    updateRemarkPIC(command: UpdateRemarkPICQuery): Observable<number>;
    getListPersonIncharge(command: GetListPersonInchargeQuery): Observable<PersonInchargeDto[]>;
    requestLeaveGroup(command: LeaveGroupRequestCommand): Observable<number>;
    registerKidsClub(command: RegisterKidsClubCommand): Observable<number>;
    searchInquiryKidClubWithPagination(memberNo: string | null | undefined, kidName: string | null | undefined, pICStore: number | null | undefined, startDate: Date | null | undefined, endDate: Date | null | undefined, orderBy: string | null | undefined, orderType: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined, deviceId: number | undefined): Observable<PaginatedListOfInquiryKidClubDto>;
    getInquiryKidClubDetail(id: number | undefined): Observable<InquiryKidClubDetailDto>;
    getListPersonInchargeCMS(createdBy: string | null | undefined): Observable<PersonInchargeDto[]>;
}

@Injectable({
    providedIn: 'root'
})
export class MembersClient implements IMembersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    create(command: RegisterMemberCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Members";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    getCardsWithMemberNo(memberNo: string | null | undefined): Observable<MemberInfoDto> {
        let url_ = this.baseUrl + "/api/Members?";
        if (memberNo !== undefined && memberNo !== null)
            url_ += "memberNo=" + encodeURIComponent("" + memberNo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCardsWithMemberNo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCardsWithMemberNo(<any>response_);
                } catch (e) {
                    return <Observable<MemberInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MemberInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCardsWithMemberNo(response: HttpResponseBase): Observable<MemberInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MemberInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MemberInfoDto>(<any>null);
    }

    importZipCode(): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Members/ImportZipCode";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportZipCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportZipCode(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processImportZipCode(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    validateCardForRegister(memberNo: string | null | undefined): Observable<CardValidationDto> {
        let url_ = this.baseUrl + "/api/Members/ValidateCardForRegister?";
        if (memberNo !== undefined && memberNo !== null)
            url_ += "memberNo=" + encodeURIComponent("" + memberNo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateCardForRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateCardForRegister(<any>response_);
                } catch (e) {
                    return <Observable<CardValidationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CardValidationDto>><any>_observableThrow(response_);
        }));
    }

    protected processValidateCardForRegister(response: HttpResponseBase): Observable<CardValidationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CardValidationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CardValidationDto>(<any>null);
    }

    getInfoZipcode(zipcode: string | null | undefined): Observable<ZipcodeDto> {
        let url_ = this.baseUrl + "/api/Members/GetInfoZipcode?";
        if (zipcode !== undefined && zipcode !== null)
            url_ += "zipcode=" + encodeURIComponent("" + zipcode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInfoZipcode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInfoZipcode(<any>response_);
                } catch (e) {
                    return <Observable<ZipcodeDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ZipcodeDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetInfoZipcode(response: HttpResponseBase): Observable<ZipcodeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ZipcodeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ZipcodeDto>(<any>null);
    }

    updateMember(command: UpdateMemberCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Members/UpdateMember";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMember(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateMember(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    updateMemberNo(command: UpdateMemberNoCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Members/UpdateMemberNo";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMemberNo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMemberNo(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateMemberNo(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    updateRemarkPIC(command: UpdateRemarkPICQuery): Observable<number> {
        let url_ = this.baseUrl + "/api/Members/UpdateRemarkPIC";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateRemarkPIC(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateRemarkPIC(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateRemarkPIC(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    getListPersonIncharge(command: GetListPersonInchargeQuery): Observable<PersonInchargeDto[]> {
        let url_ = this.baseUrl + "/api/Members/GetListPersonIncharge";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListPersonIncharge(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListPersonIncharge(<any>response_);
                } catch (e) {
                    return <Observable<PersonInchargeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PersonInchargeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetListPersonIncharge(response: HttpResponseBase): Observable<PersonInchargeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PersonInchargeDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PersonInchargeDto[]>(<any>null);
    }

    requestLeaveGroup(command: LeaveGroupRequestCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Members/RequestLeaveGroup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequestLeaveGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequestLeaveGroup(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processRequestLeaveGroup(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    registerKidsClub(command: RegisterKidsClubCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Members/RegisterKidsClub";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterKidsClub(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterKidsClub(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processRegisterKidsClub(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    searchInquiryKidClubWithPagination(memberNo: string | null | undefined, kidName: string | null | undefined, pICStore: number | null | undefined, startDate: Date | null | undefined, endDate: Date | null | undefined, orderBy: string | null | undefined, orderType: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined, deviceId: number | undefined): Observable<PaginatedListOfInquiryKidClubDto> {
        let url_ = this.baseUrl + "/api/Members/SearchInquiryKidClubWithPagination?";
        if (memberNo !== undefined && memberNo !== null)
            url_ += "MemberNo=" + encodeURIComponent("" + memberNo) + "&";
        if (kidName !== undefined && kidName !== null)
            url_ += "KidName=" + encodeURIComponent("" + kidName) + "&";
        if (pICStore !== undefined && pICStore !== null)
            url_ += "PICStore=" + encodeURIComponent("" + pICStore) + "&";
        if (startDate !== undefined && startDate !== null)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate !== undefined && endDate !== null)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        if (orderBy !== undefined && orderBy !== null)
            url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
        if (orderType !== undefined && orderType !== null)
            url_ += "OrderType=" + encodeURIComponent("" + orderType) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (deviceId === null)
            throw new Error("The parameter 'deviceId' cannot be null.");
        else if (deviceId !== undefined)
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchInquiryKidClubWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchInquiryKidClubWithPagination(<any>response_);
                } catch (e) {
                    return <Observable<PaginatedListOfInquiryKidClubDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaginatedListOfInquiryKidClubDto>><any>_observableThrow(response_);
        }));
    }

    protected processSearchInquiryKidClubWithPagination(response: HttpResponseBase): Observable<PaginatedListOfInquiryKidClubDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfInquiryKidClubDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListOfInquiryKidClubDto>(<any>null);
    }

    getInquiryKidClubDetail(id: number | undefined): Observable<InquiryKidClubDetailDto> {
        let url_ = this.baseUrl + "/api/Members/GetInquiryKidClubDetail?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInquiryKidClubDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInquiryKidClubDetail(<any>response_);
                } catch (e) {
                    return <Observable<InquiryKidClubDetailDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<InquiryKidClubDetailDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetInquiryKidClubDetail(response: HttpResponseBase): Observable<InquiryKidClubDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InquiryKidClubDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InquiryKidClubDetailDto>(<any>null);
    }

    getListPersonInchargeCMS(createdBy: string | null | undefined): Observable<PersonInchargeDto[]> {
        let url_ = this.baseUrl + "/api/Members/GetListPersonInchargeCMS?";
        if (createdBy !== undefined && createdBy !== null)
            url_ += "CreatedBy=" + encodeURIComponent("" + createdBy) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListPersonInchargeCMS(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListPersonInchargeCMS(<any>response_);
                } catch (e) {
                    return <Observable<PersonInchargeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PersonInchargeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetListPersonInchargeCMS(response: HttpResponseBase): Observable<PersonInchargeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PersonInchargeDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PersonInchargeDto[]>(<any>null);
    }
}

export interface IPICStoresClient {
    getPICStores(pageNumber: number | undefined, pageSize: number | undefined, pICCode: string | null | undefined, pICName: string | null | undefined, orderBy: string | null | undefined, orderType: string | null | undefined, deviceId: number | undefined): Observable<PaginatedListOfPICStoreDto>;
    create(command: CreatePICStoreCommand): Observable<number>;
    delete(pICCode: string | null | undefined): Observable<FileResponse>;
    update(id: number, command: UpdatePICStoreCommand): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class PICStoresClient implements IPICStoresClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getPICStores(pageNumber: number | undefined, pageSize: number | undefined, pICCode: string | null | undefined, pICName: string | null | undefined, orderBy: string | null | undefined, orderType: string | null | undefined, deviceId: number | undefined): Observable<PaginatedListOfPICStoreDto> {
        let url_ = this.baseUrl + "/api/PICStores?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pICCode !== undefined && pICCode !== null)
            url_ += "PICCode=" + encodeURIComponent("" + pICCode) + "&";
        if (pICName !== undefined && pICName !== null)
            url_ += "PICName=" + encodeURIComponent("" + pICName) + "&";
        if (orderBy !== undefined && orderBy !== null)
            url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
        if (orderType !== undefined && orderType !== null)
            url_ += "OrderType=" + encodeURIComponent("" + orderType) + "&";
        if (deviceId === null)
            throw new Error("The parameter 'deviceId' cannot be null.");
        else if (deviceId !== undefined)
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPICStores(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPICStores(<any>response_);
                } catch (e) {
                    return <Observable<PaginatedListOfPICStoreDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaginatedListOfPICStoreDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPICStores(response: HttpResponseBase): Observable<PaginatedListOfPICStoreDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfPICStoreDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListOfPICStoreDto>(<any>null);
    }

    create(command: CreatePICStoreCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/PICStores";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    delete(pICCode: string | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/PICStores?";
        if (pICCode !== undefined && pICCode !== null)
            url_ += "PICCode=" + encodeURIComponent("" + pICCode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    update(id: number, command: UpdatePICStoreCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/PICStores/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface IReceptionClient {
    getCardsWithCondition(fromDate: string | null | undefined, toDate: string | null | undefined, deviceId: number | undefined): Observable<ReceptionGraphResult>;
    getCardsWithPagination(fromDate: string | null | undefined, toDate: string | null | undefined, deviceId: number | undefined, pageSize: number | undefined, pageNumber: number | undefined): Observable<PaginatedListOfReceptionDetailDto>;
    getAdminCardsWithCondition(fromDate: string | null | undefined, toDate: string | null | undefined, isSearchCreateCards: boolean | undefined, isSearchSwitchCards: boolean | undefined, isSearchReissuedCards: boolean | undefined, isSearchChangeCards: boolean | undefined, isSearchDiscardCards: boolean | undefined, isSearchPointMigration: boolean | undefined, isSearchKidClubs: boolean | undefined): Observable<ReceptionGraphResult>;
    getAdminCardsWithPagination(fromDate: string | null | undefined, toDate: string | null | undefined, isSearchCreateCards: boolean | undefined, isSearchSwitchCards: boolean | undefined, isSearchReissuedCards: boolean | undefined, isSearchChangeCards: boolean | undefined, isSearchDiscardCards: boolean | undefined, isSearchPointMigration: boolean | undefined, isSearchKidClubs: boolean | undefined, pageSize: number | undefined, pageNumber: number | undefined): Observable<PaginatedListOfReceptionDetailDto>;
    getAdminReceptionsExportTable(fromDate: string | null | undefined, toDate: string | null | undefined, isSearchCreateCards: boolean | undefined, isSearchSwitchCards: boolean | undefined, isSearchReissuedCards: boolean | undefined, isSearchChangeCards: boolean | undefined, isSearchDiscardCards: boolean | undefined, isSearchPointMigration: boolean | undefined, isSearchKidClubs: boolean | undefined): Observable<FileResponse>;
    getAdminReceptionsExportGraph(file: FileParameter | null | undefined): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class ReceptionClient implements IReceptionClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getCardsWithCondition(fromDate: string | null | undefined, toDate: string | null | undefined, deviceId: number | undefined): Observable<ReceptionGraphResult> {
        let url_ = this.baseUrl + "/api/Reception/GetCardsWithCondition?";
        if (fromDate !== undefined && fromDate !== null)
            url_ += "FromDate=" + encodeURIComponent("" + fromDate) + "&";
        if (toDate !== undefined && toDate !== null)
            url_ += "ToDate=" + encodeURIComponent("" + toDate) + "&";
        if (deviceId === null)
            throw new Error("The parameter 'deviceId' cannot be null.");
        else if (deviceId !== undefined)
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCardsWithCondition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCardsWithCondition(<any>response_);
                } catch (e) {
                    return <Observable<ReceptionGraphResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReceptionGraphResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetCardsWithCondition(response: HttpResponseBase): Observable<ReceptionGraphResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReceptionGraphResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReceptionGraphResult>(<any>null);
    }

    getCardsWithPagination(fromDate: string | null | undefined, toDate: string | null | undefined, deviceId: number | undefined, pageSize: number | undefined, pageNumber: number | undefined): Observable<PaginatedListOfReceptionDetailDto> {
        let url_ = this.baseUrl + "/api/Reception/GetCardsWithPagination?";
        if (fromDate !== undefined && fromDate !== null)
            url_ += "FromDate=" + encodeURIComponent("" + fromDate) + "&";
        if (toDate !== undefined && toDate !== null)
            url_ += "ToDate=" + encodeURIComponent("" + toDate) + "&";
        if (deviceId === null)
            throw new Error("The parameter 'deviceId' cannot be null.");
        else if (deviceId !== undefined)
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCardsWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCardsWithPagination(<any>response_);
                } catch (e) {
                    return <Observable<PaginatedListOfReceptionDetailDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaginatedListOfReceptionDetailDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCardsWithPagination(response: HttpResponseBase): Observable<PaginatedListOfReceptionDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfReceptionDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListOfReceptionDetailDto>(<any>null);
    }

    getAdminCardsWithCondition(fromDate: string | null | undefined, toDate: string | null | undefined, isSearchCreateCards: boolean | undefined, isSearchSwitchCards: boolean | undefined, isSearchReissuedCards: boolean | undefined, isSearchChangeCards: boolean | undefined, isSearchDiscardCards: boolean | undefined, isSearchPointMigration: boolean | undefined, isSearchKidClubs: boolean | undefined): Observable<ReceptionGraphResult> {
        let url_ = this.baseUrl + "/api/Reception/GetAdminCardsWithCondition?";
        if (fromDate !== undefined && fromDate !== null)
            url_ += "FromDate=" + encodeURIComponent("" + fromDate) + "&";
        if (toDate !== undefined && toDate !== null)
            url_ += "ToDate=" + encodeURIComponent("" + toDate) + "&";
        if (isSearchCreateCards === null)
            throw new Error("The parameter 'isSearchCreateCards' cannot be null.");
        else if (isSearchCreateCards !== undefined)
            url_ += "IsSearchCreateCards=" + encodeURIComponent("" + isSearchCreateCards) + "&";
        if (isSearchSwitchCards === null)
            throw new Error("The parameter 'isSearchSwitchCards' cannot be null.");
        else if (isSearchSwitchCards !== undefined)
            url_ += "IsSearchSwitchCards=" + encodeURIComponent("" + isSearchSwitchCards) + "&";
        if (isSearchReissuedCards === null)
            throw new Error("The parameter 'isSearchReissuedCards' cannot be null.");
        else if (isSearchReissuedCards !== undefined)
            url_ += "IsSearchReissuedCards=" + encodeURIComponent("" + isSearchReissuedCards) + "&";
        if (isSearchChangeCards === null)
            throw new Error("The parameter 'isSearchChangeCards' cannot be null.");
        else if (isSearchChangeCards !== undefined)
            url_ += "IsSearchChangeCards=" + encodeURIComponent("" + isSearchChangeCards) + "&";
        if (isSearchDiscardCards === null)
            throw new Error("The parameter 'isSearchDiscardCards' cannot be null.");
        else if (isSearchDiscardCards !== undefined)
            url_ += "IsSearchDiscardCards=" + encodeURIComponent("" + isSearchDiscardCards) + "&";
        if (isSearchPointMigration === null)
            throw new Error("The parameter 'isSearchPointMigration' cannot be null.");
        else if (isSearchPointMigration !== undefined)
            url_ += "IsSearchPointMigration=" + encodeURIComponent("" + isSearchPointMigration) + "&";
        if (isSearchKidClubs === null)
            throw new Error("The parameter 'isSearchKidClubs' cannot be null.");
        else if (isSearchKidClubs !== undefined)
            url_ += "IsSearchKidClubs=" + encodeURIComponent("" + isSearchKidClubs) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdminCardsWithCondition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdminCardsWithCondition(<any>response_);
                } catch (e) {
                    return <Observable<ReceptionGraphResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<ReceptionGraphResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetAdminCardsWithCondition(response: HttpResponseBase): Observable<ReceptionGraphResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ReceptionGraphResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ReceptionGraphResult>(<any>null);
    }

    getAdminCardsWithPagination(fromDate: string | null | undefined, toDate: string | null | undefined, isSearchCreateCards: boolean | undefined, isSearchSwitchCards: boolean | undefined, isSearchReissuedCards: boolean | undefined, isSearchChangeCards: boolean | undefined, isSearchDiscardCards: boolean | undefined, isSearchPointMigration: boolean | undefined, isSearchKidClubs: boolean | undefined, pageSize: number | undefined, pageNumber: number | undefined): Observable<PaginatedListOfReceptionDetailDto> {
        let url_ = this.baseUrl + "/api/Reception/GetAdminCardsWithPagination?";
        if (fromDate !== undefined && fromDate !== null)
            url_ += "FromDate=" + encodeURIComponent("" + fromDate) + "&";
        if (toDate !== undefined && toDate !== null)
            url_ += "ToDate=" + encodeURIComponent("" + toDate) + "&";
        if (isSearchCreateCards === null)
            throw new Error("The parameter 'isSearchCreateCards' cannot be null.");
        else if (isSearchCreateCards !== undefined)
            url_ += "IsSearchCreateCards=" + encodeURIComponent("" + isSearchCreateCards) + "&";
        if (isSearchSwitchCards === null)
            throw new Error("The parameter 'isSearchSwitchCards' cannot be null.");
        else if (isSearchSwitchCards !== undefined)
            url_ += "IsSearchSwitchCards=" + encodeURIComponent("" + isSearchSwitchCards) + "&";
        if (isSearchReissuedCards === null)
            throw new Error("The parameter 'isSearchReissuedCards' cannot be null.");
        else if (isSearchReissuedCards !== undefined)
            url_ += "IsSearchReissuedCards=" + encodeURIComponent("" + isSearchReissuedCards) + "&";
        if (isSearchChangeCards === null)
            throw new Error("The parameter 'isSearchChangeCards' cannot be null.");
        else if (isSearchChangeCards !== undefined)
            url_ += "IsSearchChangeCards=" + encodeURIComponent("" + isSearchChangeCards) + "&";
        if (isSearchDiscardCards === null)
            throw new Error("The parameter 'isSearchDiscardCards' cannot be null.");
        else if (isSearchDiscardCards !== undefined)
            url_ += "IsSearchDiscardCards=" + encodeURIComponent("" + isSearchDiscardCards) + "&";
        if (isSearchPointMigration === null)
            throw new Error("The parameter 'isSearchPointMigration' cannot be null.");
        else if (isSearchPointMigration !== undefined)
            url_ += "IsSearchPointMigration=" + encodeURIComponent("" + isSearchPointMigration) + "&";
        if (isSearchKidClubs === null)
            throw new Error("The parameter 'isSearchKidClubs' cannot be null.");
        else if (isSearchKidClubs !== undefined)
            url_ += "IsSearchKidClubs=" + encodeURIComponent("" + isSearchKidClubs) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdminCardsWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdminCardsWithPagination(<any>response_);
                } catch (e) {
                    return <Observable<PaginatedListOfReceptionDetailDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaginatedListOfReceptionDetailDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAdminCardsWithPagination(response: HttpResponseBase): Observable<PaginatedListOfReceptionDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfReceptionDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListOfReceptionDetailDto>(<any>null);
    }

    getAdminReceptionsExportTable(fromDate: string | null | undefined, toDate: string | null | undefined, isSearchCreateCards: boolean | undefined, isSearchSwitchCards: boolean | undefined, isSearchReissuedCards: boolean | undefined, isSearchChangeCards: boolean | undefined, isSearchDiscardCards: boolean | undefined, isSearchPointMigration: boolean | undefined, isSearchKidClubs: boolean | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Reception/GetAdminReceptionsExportTable?";
        if (fromDate !== undefined && fromDate !== null)
            url_ += "FromDate=" + encodeURIComponent("" + fromDate) + "&";
        if (toDate !== undefined && toDate !== null)
            url_ += "ToDate=" + encodeURIComponent("" + toDate) + "&";
        if (isSearchCreateCards === null)
            throw new Error("The parameter 'isSearchCreateCards' cannot be null.");
        else if (isSearchCreateCards !== undefined)
            url_ += "IsSearchCreateCards=" + encodeURIComponent("" + isSearchCreateCards) + "&";
        if (isSearchSwitchCards === null)
            throw new Error("The parameter 'isSearchSwitchCards' cannot be null.");
        else if (isSearchSwitchCards !== undefined)
            url_ += "IsSearchSwitchCards=" + encodeURIComponent("" + isSearchSwitchCards) + "&";
        if (isSearchReissuedCards === null)
            throw new Error("The parameter 'isSearchReissuedCards' cannot be null.");
        else if (isSearchReissuedCards !== undefined)
            url_ += "IsSearchReissuedCards=" + encodeURIComponent("" + isSearchReissuedCards) + "&";
        if (isSearchChangeCards === null)
            throw new Error("The parameter 'isSearchChangeCards' cannot be null.");
        else if (isSearchChangeCards !== undefined)
            url_ += "IsSearchChangeCards=" + encodeURIComponent("" + isSearchChangeCards) + "&";
        if (isSearchDiscardCards === null)
            throw new Error("The parameter 'isSearchDiscardCards' cannot be null.");
        else if (isSearchDiscardCards !== undefined)
            url_ += "IsSearchDiscardCards=" + encodeURIComponent("" + isSearchDiscardCards) + "&";
        if (isSearchPointMigration === null)
            throw new Error("The parameter 'isSearchPointMigration' cannot be null.");
        else if (isSearchPointMigration !== undefined)
            url_ += "IsSearchPointMigration=" + encodeURIComponent("" + isSearchPointMigration) + "&";
        if (isSearchKidClubs === null)
            throw new Error("The parameter 'isSearchKidClubs' cannot be null.");
        else if (isSearchKidClubs !== undefined)
            url_ += "IsSearchKidClubs=" + encodeURIComponent("" + isSearchKidClubs) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdminReceptionsExportTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdminReceptionsExportTable(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetAdminReceptionsExportTable(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getAdminReceptionsExportGraph(file: FileParameter | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Reception/GetAdminReceptionsExportGraph";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("File", file.data, file.fileName ? file.fileName : "File");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdminReceptionsExportGraph(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdminReceptionsExportGraph(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetAdminReceptionsExportGraph(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface IRequestsReceiptedsClient {
    getRequestsReceiptedsWithPagination(pageNumber: number | undefined, pageSize: number | undefined, memberNo: string | null | undefined, requestType: number | null | undefined, company: string | null | undefined, store: string | null | undefined, device: string | null | undefined, fromDate: Date | null | undefined, toDate: Date | null | undefined, createdBy: string | null | undefined, orderBy: string | null | undefined, orderType: string | null | undefined, isMobileRequest: boolean | undefined, pICStoreId: number | null | undefined): Observable<PaginatedListOfRequestsReceiptedDto>;
    getRequestsReceiptedsWithPaginationMobile(pageNumber: number | undefined, pageSize: number | undefined, memberNo: string | null | undefined, requestType: number | null | undefined, company: string | null | undefined, store: string | null | undefined, device: string | null | undefined, fromDate: Date | null | undefined, toDate: Date | null | undefined, createdBy: string | null | undefined, orderBy: string | null | undefined, orderType: string | null | undefined, isMobileRequest: boolean | undefined, pICStoreId: number | null | undefined): Observable<PaginatedListOfRequestsReceiptedDto>;
    getRequestsReceipted(id: number | undefined): Observable<RequestsReceiptedDetailsDto>;
    getRequestsReceiptedMobile(id: number | undefined): Observable<RequestsReceiptedDetailsDto>;
    delete(id: number): Observable<FileResponse>;
    update(id: number, command: UpdateHistoryCommand): Observable<FileResponse>;
    exportRequestReceipt(memberNo: string | null | undefined, requestType: number | null | undefined, company: string | null | undefined, store: string | null | undefined, device: string | null | undefined, fromDate: Date | null | undefined, toDate: Date | null | undefined, createdBy: string | null | undefined, isMobileRequest: boolean | undefined, pICStoreId: number | null | undefined): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class RequestsReceiptedsClient implements IRequestsReceiptedsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getRequestsReceiptedsWithPagination(pageNumber: number | undefined, pageSize: number | undefined, memberNo: string | null | undefined, requestType: number | null | undefined, company: string | null | undefined, store: string | null | undefined, device: string | null | undefined, fromDate: Date | null | undefined, toDate: Date | null | undefined, createdBy: string | null | undefined, orderBy: string | null | undefined, orderType: string | null | undefined, isMobileRequest: boolean | undefined, pICStoreId: number | null | undefined): Observable<PaginatedListOfRequestsReceiptedDto> {
        let url_ = this.baseUrl + "/api/RequestsReceipteds?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (memberNo !== undefined && memberNo !== null)
            url_ += "MemberNo=" + encodeURIComponent("" + memberNo) + "&";
        if (requestType !== undefined && requestType !== null)
            url_ += "RequestType=" + encodeURIComponent("" + requestType) + "&";
        if (company !== undefined && company !== null)
            url_ += "Company=" + encodeURIComponent("" + company) + "&";
        if (store !== undefined && store !== null)
            url_ += "Store=" + encodeURIComponent("" + store) + "&";
        if (device !== undefined && device !== null)
            url_ += "Device=" + encodeURIComponent("" + device) + "&";
        if (fromDate !== undefined && fromDate !== null)
            url_ += "FromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toJSON() : "") + "&";
        if (toDate !== undefined && toDate !== null)
            url_ += "ToDate=" + encodeURIComponent(toDate ? "" + toDate.toJSON() : "") + "&";
        if (createdBy !== undefined && createdBy !== null)
            url_ += "CreatedBy=" + encodeURIComponent("" + createdBy) + "&";
        if (orderBy !== undefined && orderBy !== null)
            url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
        if (orderType !== undefined && orderType !== null)
            url_ += "OrderType=" + encodeURIComponent("" + orderType) + "&";
        if (isMobileRequest === null)
            throw new Error("The parameter 'isMobileRequest' cannot be null.");
        else if (isMobileRequest !== undefined)
            url_ += "IsMobileRequest=" + encodeURIComponent("" + isMobileRequest) + "&";
        if (pICStoreId !== undefined && pICStoreId !== null)
            url_ += "PICStoreId=" + encodeURIComponent("" + pICStoreId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRequestsReceiptedsWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRequestsReceiptedsWithPagination(<any>response_);
                } catch (e) {
                    return <Observable<PaginatedListOfRequestsReceiptedDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaginatedListOfRequestsReceiptedDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRequestsReceiptedsWithPagination(response: HttpResponseBase): Observable<PaginatedListOfRequestsReceiptedDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfRequestsReceiptedDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListOfRequestsReceiptedDto>(<any>null);
    }

    getRequestsReceiptedsWithPaginationMobile(pageNumber: number | undefined, pageSize: number | undefined, memberNo: string | null | undefined, requestType: number | null | undefined, company: string | null | undefined, store: string | null | undefined, device: string | null | undefined, fromDate: Date | null | undefined, toDate: Date | null | undefined, createdBy: string | null | undefined, orderBy: string | null | undefined, orderType: string | null | undefined, isMobileRequest: boolean | undefined, pICStoreId: number | null | undefined): Observable<PaginatedListOfRequestsReceiptedDto> {
        let url_ = this.baseUrl + "/api/RequestsReceipteds/GetRequestsReceiptedsWithPaginationMobile?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (memberNo !== undefined && memberNo !== null)
            url_ += "MemberNo=" + encodeURIComponent("" + memberNo) + "&";
        if (requestType !== undefined && requestType !== null)
            url_ += "RequestType=" + encodeURIComponent("" + requestType) + "&";
        if (company !== undefined && company !== null)
            url_ += "Company=" + encodeURIComponent("" + company) + "&";
        if (store !== undefined && store !== null)
            url_ += "Store=" + encodeURIComponent("" + store) + "&";
        if (device !== undefined && device !== null)
            url_ += "Device=" + encodeURIComponent("" + device) + "&";
        if (fromDate !== undefined && fromDate !== null)
            url_ += "FromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toJSON() : "") + "&";
        if (toDate !== undefined && toDate !== null)
            url_ += "ToDate=" + encodeURIComponent(toDate ? "" + toDate.toJSON() : "") + "&";
        if (createdBy !== undefined && createdBy !== null)
            url_ += "CreatedBy=" + encodeURIComponent("" + createdBy) + "&";
        if (orderBy !== undefined && orderBy !== null)
            url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
        if (orderType !== undefined && orderType !== null)
            url_ += "OrderType=" + encodeURIComponent("" + orderType) + "&";
        if (isMobileRequest === null)
            throw new Error("The parameter 'isMobileRequest' cannot be null.");
        else if (isMobileRequest !== undefined)
            url_ += "IsMobileRequest=" + encodeURIComponent("" + isMobileRequest) + "&";
        if (pICStoreId !== undefined && pICStoreId !== null)
            url_ += "PICStoreId=" + encodeURIComponent("" + pICStoreId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRequestsReceiptedsWithPaginationMobile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRequestsReceiptedsWithPaginationMobile(<any>response_);
                } catch (e) {
                    return <Observable<PaginatedListOfRequestsReceiptedDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaginatedListOfRequestsReceiptedDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRequestsReceiptedsWithPaginationMobile(response: HttpResponseBase): Observable<PaginatedListOfRequestsReceiptedDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfRequestsReceiptedDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListOfRequestsReceiptedDto>(<any>null);
    }

    getRequestsReceipted(id: number | undefined): Observable<RequestsReceiptedDetailsDto> {
        let url_ = this.baseUrl + "/api/RequestsReceipteds/GetRequestsReceipted?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRequestsReceipted(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRequestsReceipted(<any>response_);
                } catch (e) {
                    return <Observable<RequestsReceiptedDetailsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestsReceiptedDetailsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRequestsReceipted(response: HttpResponseBase): Observable<RequestsReceiptedDetailsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestsReceiptedDetailsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestsReceiptedDetailsDto>(<any>null);
    }

    getRequestsReceiptedMobile(id: number | undefined): Observable<RequestsReceiptedDetailsDto> {
        let url_ = this.baseUrl + "/api/RequestsReceipteds/GetRequestsReceiptedMobile?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRequestsReceiptedMobile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRequestsReceiptedMobile(<any>response_);
                } catch (e) {
                    return <Observable<RequestsReceiptedDetailsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestsReceiptedDetailsDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRequestsReceiptedMobile(response: HttpResponseBase): Observable<RequestsReceiptedDetailsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RequestsReceiptedDetailsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestsReceiptedDetailsDto>(<any>null);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/RequestsReceipteds/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    update(id: number, command: UpdateHistoryCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/RequestsReceipteds/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    exportRequestReceipt(memberNo: string | null | undefined, requestType: number | null | undefined, company: string | null | undefined, store: string | null | undefined, device: string | null | undefined, fromDate: Date | null | undefined, toDate: Date | null | undefined, createdBy: string | null | undefined, isMobileRequest: boolean | undefined, pICStoreId: number | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/RequestsReceipteds/ExportRequestReceipt?";
        if (memberNo !== undefined && memberNo !== null)
            url_ += "MemberNo=" + encodeURIComponent("" + memberNo) + "&";
        if (requestType !== undefined && requestType !== null)
            url_ += "RequestType=" + encodeURIComponent("" + requestType) + "&";
        if (company !== undefined && company !== null)
            url_ += "Company=" + encodeURIComponent("" + company) + "&";
        if (store !== undefined && store !== null)
            url_ += "Store=" + encodeURIComponent("" + store) + "&";
        if (device !== undefined && device !== null)
            url_ += "Device=" + encodeURIComponent("" + device) + "&";
        if (fromDate !== undefined && fromDate !== null)
            url_ += "FromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toJSON() : "") + "&";
        if (toDate !== undefined && toDate !== null)
            url_ += "ToDate=" + encodeURIComponent(toDate ? "" + toDate.toJSON() : "") + "&";
        if (createdBy !== undefined && createdBy !== null)
            url_ += "CreatedBy=" + encodeURIComponent("" + createdBy) + "&";
        if (isMobileRequest === null)
            throw new Error("The parameter 'isMobileRequest' cannot be null.");
        else if (isMobileRequest !== undefined)
            url_ += "IsMobileRequest=" + encodeURIComponent("" + isMobileRequest) + "&";
        if (pICStoreId !== undefined && pICStoreId !== null)
            url_ += "PICStoreId=" + encodeURIComponent("" + pICStoreId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportRequestReceipt(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportRequestReceipt(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processExportRequestReceipt(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface IStoresClient {
    getStoresWithPagination(companyCode: string | null | undefined, companyName: string | null | undefined, storeCode: string | null | undefined, storeName: string | null | undefined, orderBy: string | null | undefined, orderType: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfStoreDto>;
    create(command: CreateStoreCommand): Observable<number>;
    getStores(): Observable<StoresVm>;
    update(id: number, command: UpdateStoreCommand): Observable<FileResponse>;
    delete(id: number, command: DeleteStoreCommand): Observable<FileResponse>;
    updateItemDetails(id: number | undefined, command: UpdateStoreCommand): Observable<FileResponse>;
    getStoreByLoggedInUser(): Observable<StoreByUserDto>;
}

@Injectable({
    providedIn: 'root'
})
export class StoresClient implements IStoresClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getStoresWithPagination(companyCode: string | null | undefined, companyName: string | null | undefined, storeCode: string | null | undefined, storeName: string | null | undefined, orderBy: string | null | undefined, orderType: string | null | undefined, pageNumber: number | undefined, pageSize: number | undefined): Observable<PaginatedListOfStoreDto> {
        let url_ = this.baseUrl + "/api/Stores?";
        if (companyCode !== undefined && companyCode !== null)
            url_ += "CompanyCode=" + encodeURIComponent("" + companyCode) + "&";
        if (companyName !== undefined && companyName !== null)
            url_ += "CompanyName=" + encodeURIComponent("" + companyName) + "&";
        if (storeCode !== undefined && storeCode !== null)
            url_ += "StoreCode=" + encodeURIComponent("" + storeCode) + "&";
        if (storeName !== undefined && storeName !== null)
            url_ += "StoreName=" + encodeURIComponent("" + storeName) + "&";
        if (orderBy !== undefined && orderBy !== null)
            url_ += "OrderBy=" + encodeURIComponent("" + orderBy) + "&";
        if (orderType !== undefined && orderType !== null)
            url_ += "OrderType=" + encodeURIComponent("" + orderType) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoresWithPagination(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoresWithPagination(<any>response_);
                } catch (e) {
                    return <Observable<PaginatedListOfStoreDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaginatedListOfStoreDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetStoresWithPagination(response: HttpResponseBase): Observable<PaginatedListOfStoreDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfStoreDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListOfStoreDto>(<any>null);
    }

    create(command: CreateStoreCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Stores";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    getStores(): Observable<StoresVm> {
        let url_ = this.baseUrl + "/api/Stores/GetStores";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStores(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStores(<any>response_);
                } catch (e) {
                    return <Observable<StoresVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<StoresVm>><any>_observableThrow(response_);
        }));
    }

    protected processGetStores(response: HttpResponseBase): Observable<StoresVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StoresVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StoresVm>(<any>null);
    }

    update(id: number, command: UpdateStoreCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Stores/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    delete(id: number, command: DeleteStoreCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Stores/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    updateItemDetails(id: number | undefined, command: UpdateStoreCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Stores/UpdateItemDetails?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateItemDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateItemDetails(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateItemDetails(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getStoreByLoggedInUser(): Observable<StoreByUserDto> {
        let url_ = this.baseUrl + "/api/Stores/GetStoreByLoggedInUser";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStoreByLoggedInUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStoreByLoggedInUser(<any>response_);
                } catch (e) {
                    return <Observable<StoreByUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<StoreByUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetStoreByLoggedInUser(response: HttpResponseBase): Observable<StoreByUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StoreByUserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StoreByUserDto>(<any>null);
    }
}

export interface IUsersClient {
    create(command: CreateUserCommand): Observable<CreateUserResultDto>;
    update(command: UpdateUserCommand): Observable<UpdateUserResultDto>;
    get(companyCode: string | null | undefined, companyName: string | null | undefined, userName: string | null | undefined, fullName: string | null | undefined, page: number | undefined, size: number | undefined, sortBy: string | null | undefined, sortDimension: string | null | undefined): Observable<PaginatedListOfUserDto>;
    delete(id: string | null): Observable<DeleteUserResultDto>;
}

@Injectable({
    providedIn: 'root'
})
export class UsersClient implements IUsersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    create(command: CreateUserCommand): Observable<CreateUserResultDto> {
        let url_ = this.baseUrl + "/api/Users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<CreateUserResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateUserResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<CreateUserResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateUserResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateUserResultDto>(<any>null);
    }

    update(command: UpdateUserCommand): Observable<UpdateUserResultDto> {
        let url_ = this.baseUrl + "/api/Users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<UpdateUserResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UpdateUserResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UpdateUserResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateUserResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateUserResultDto>(<any>null);
    }

    get(companyCode: string | null | undefined, companyName: string | null | undefined, userName: string | null | undefined, fullName: string | null | undefined, page: number | undefined, size: number | undefined, sortBy: string | null | undefined, sortDimension: string | null | undefined): Observable<PaginatedListOfUserDto> {
        let url_ = this.baseUrl + "/api/Users?";
        if (companyCode !== undefined && companyCode !== null)
            url_ += "CompanyCode=" + encodeURIComponent("" + companyCode) + "&";
        if (companyName !== undefined && companyName !== null)
            url_ += "CompanyName=" + encodeURIComponent("" + companyName) + "&";
        if (userName !== undefined && userName !== null)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (fullName !== undefined && fullName !== null)
            url_ += "FullName=" + encodeURIComponent("" + fullName) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "Size=" + encodeURIComponent("" + size) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDimension !== undefined && sortDimension !== null)
            url_ += "SortDimension=" + encodeURIComponent("" + sortDimension) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<PaginatedListOfUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaginatedListOfUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PaginatedListOfUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedListOfUserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginatedListOfUserDto>(<any>null);
    }

    delete(id: string | null): Observable<DeleteUserResultDto> {
        let url_ = this.baseUrl + "/api/Users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<DeleteUserResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DeleteUserResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<DeleteUserResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DeleteUserResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeleteUserResultDto>(<any>null);
    }
}

export class CreateCardCommand implements ICreateCardCommand {
    memberNo?: string | undefined;
    isActive?: boolean;
    isBlock?: boolean;
    point?: string | undefined;

    constructor(data?: ICreateCardCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberNo = _data["memberNo"];
            this.isActive = _data["isActive"];
            this.isBlock = _data["isBlock"];
            this.point = _data["point"];
        }
    }

    static fromJS(data: any): CreateCardCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCardCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberNo"] = this.memberNo;
        data["isActive"] = this.isActive;
        data["isBlock"] = this.isBlock;
        data["point"] = this.point;
        return data; 
    }
}

export interface ICreateCardCommand {
    memberNo?: string | undefined;
    isActive?: boolean;
    isBlock?: boolean;
    point?: string | undefined;
}

export class UpdateCardCommand implements IUpdateCardCommand {
    id?: number;
    status?: CardStatus;
    store?: FlatStoreDto | undefined;
    company?: FlatCompanyDto | undefined;

    constructor(data?: IUpdateCardCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.status = _data["status"];
            this.store = _data["store"] ? FlatStoreDto.fromJS(_data["store"]) : <any>undefined;
            this.company = _data["company"] ? FlatCompanyDto.fromJS(_data["company"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateCardCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCardCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["status"] = this.status;
        data["store"] = this.store ? this.store.toJSON() : <any>undefined;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IUpdateCardCommand {
    id?: number;
    status?: CardStatus;
    store?: FlatStoreDto | undefined;
    company?: FlatCompanyDto | undefined;
}

export enum CardStatus {
    Unissued = 1,
    Issued = 2,
    Withdrawal = 3,
    Missing = 4,
    Disposal = 5,
}

export class FlatStoreDto implements IFlatStoreDto {
    id?: number;
    storeCode?: string | undefined;
    storeName?: string | undefined;
    companyId?: number;
    normalizedStoreName?: string | undefined;
    isDeleted?: boolean;
    isActive?: boolean;

    constructor(data?: IFlatStoreDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.storeCode = _data["storeCode"];
            this.storeName = _data["storeName"];
            this.companyId = _data["companyId"];
            this.normalizedStoreName = _data["normalizedStoreName"];
            this.isDeleted = _data["isDeleted"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): FlatStoreDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatStoreDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["storeCode"] = this.storeCode;
        data["storeName"] = this.storeName;
        data["companyId"] = this.companyId;
        data["normalizedStoreName"] = this.normalizedStoreName;
        data["isDeleted"] = this.isDeleted;
        data["isActive"] = this.isActive;
        return data; 
    }
}

export interface IFlatStoreDto {
    id?: number;
    storeCode?: string | undefined;
    storeName?: string | undefined;
    companyId?: number;
    normalizedStoreName?: string | undefined;
    isDeleted?: boolean;
    isActive?: boolean;
}

export class FlatCompanyDto implements IFlatCompanyDto {
    id?: number;
    companyCode?: string | undefined;
    companyName?: string | undefined;
    normalizedCompanyName?: string | undefined;
    order?: number;
    isActive?: boolean;
    isDeleted?: boolean;

    constructor(data?: IFlatCompanyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyCode = _data["companyCode"];
            this.companyName = _data["companyName"];
            this.normalizedCompanyName = _data["normalizedCompanyName"];
            this.order = _data["order"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
        }
    }

    static fromJS(data: any): FlatCompanyDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatCompanyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyCode"] = this.companyCode;
        data["companyName"] = this.companyName;
        data["normalizedCompanyName"] = this.normalizedCompanyName;
        data["order"] = this.order;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        return data; 
    }
}

export interface IFlatCompanyDto {
    id?: number;
    companyCode?: string | undefined;
    companyName?: string | undefined;
    normalizedCompanyName?: string | undefined;
    order?: number;
    isActive?: boolean;
    isDeleted?: boolean;
}

export class CardDto implements ICardDto {
    id?: number;
    memberNo?: string | undefined;
    status?: CardStatus;
    point?: string | undefined;
    storeId?: number | undefined;
    companyId?: number | undefined;
    expiredAt?: Date;
    store?: Store | undefined;
    company?: Company | undefined;
    createdAt?: Date;
    createdBy?: string | undefined;
    createdByName?: string | undefined;
    updatedAt?: Date | undefined;
    updatedBy?: string | undefined;
    updatedByName?: string | undefined;
    isDeleted?: boolean;
    deletedAt?: Date | undefined;
    deletedBy?: string | undefined;
    updateder?: ApplicationUserDto | undefined;
    createder?: ApplicationUserDto | undefined;

    constructor(data?: ICardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.memberNo = _data["memberNo"];
            this.status = _data["status"];
            this.point = _data["point"];
            this.storeId = _data["storeId"];
            this.companyId = _data["companyId"];
            this.expiredAt = _data["expiredAt"] ? new Date(_data["expiredAt"].toString()) : <any>undefined;
            this.store = _data["store"] ? Store.fromJS(_data["store"]) : <any>undefined;
            this.company = _data["company"] ? Company.fromJS(_data["company"]) : <any>undefined;
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.createdByName = _data["createdByName"];
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            this.updatedByName = _data["updatedByName"];
            this.isDeleted = _data["isDeleted"];
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.deletedBy = _data["deletedBy"];
            this.updateder = _data["updateder"] ? ApplicationUserDto.fromJS(_data["updateder"]) : <any>undefined;
            this.createder = _data["createder"] ? ApplicationUserDto.fromJS(_data["createder"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CardDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["memberNo"] = this.memberNo;
        data["status"] = this.status;
        data["point"] = this.point;
        data["storeId"] = this.storeId;
        data["companyId"] = this.companyId;
        data["expiredAt"] = this.expiredAt ? this.expiredAt.toISOString() : <any>undefined;
        data["store"] = this.store ? this.store.toJSON() : <any>undefined;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["createdByName"] = this.createdByName;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        data["updatedByName"] = this.updatedByName;
        data["isDeleted"] = this.isDeleted;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["deletedBy"] = this.deletedBy;
        data["updateder"] = this.updateder ? this.updateder.toJSON() : <any>undefined;
        data["createder"] = this.createder ? this.createder.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICardDto {
    id?: number;
    memberNo?: string | undefined;
    status?: CardStatus;
    point?: string | undefined;
    storeId?: number | undefined;
    companyId?: number | undefined;
    expiredAt?: Date;
    store?: Store | undefined;
    company?: Company | undefined;
    createdAt?: Date;
    createdBy?: string | undefined;
    createdByName?: string | undefined;
    updatedAt?: Date | undefined;
    updatedBy?: string | undefined;
    updatedByName?: string | undefined;
    isDeleted?: boolean;
    deletedAt?: Date | undefined;
    deletedBy?: string | undefined;
    updateder?: ApplicationUserDto | undefined;
    createder?: ApplicationUserDto | undefined;
}

export abstract class AuditableEntity implements IAuditableEntity {
    createdAt?: Date;
    createdBy?: string | undefined;
    updatedAt?: Date | undefined;
    updatedBy?: string | undefined;
    isDeleted?: boolean;
    deletedAt?: Date | undefined;
    deletedBy?: string | undefined;

    constructor(data?: IAuditableEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            this.isDeleted = _data["isDeleted"];
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.deletedBy = _data["deletedBy"];
        }
    }

    static fromJS(data: any): AuditableEntity {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'AuditableEntity' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        data["isDeleted"] = this.isDeleted;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["deletedBy"] = this.deletedBy;
        return data; 
    }
}

export interface IAuditableEntity {
    createdAt?: Date;
    createdBy?: string | undefined;
    updatedAt?: Date | undefined;
    updatedBy?: string | undefined;
    isDeleted?: boolean;
    deletedAt?: Date | undefined;
    deletedBy?: string | undefined;
}

export class Store extends AuditableEntity implements IStore {
    id?: number;
    storeCode?: string | undefined;
    storeName?: string | undefined;
    companyId?: number;
    normalizedStoreName?: string | undefined;
    order?: number;
    isActive?: boolean;
    cards?: Card[] | undefined;
    devices?: Device[] | undefined;
    requestsPendings?: RequestsPending[] | undefined;
    requestsReceipteds?: RequestsReceipted[] | undefined;
    company?: Company | undefined;

    constructor(data?: IStore) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.storeCode = _data["storeCode"];
            this.storeName = _data["storeName"];
            this.companyId = _data["companyId"];
            this.normalizedStoreName = _data["normalizedStoreName"];
            this.order = _data["order"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["cards"])) {
                this.cards = [] as any;
                for (let item of _data["cards"])
                    this.cards!.push(Card.fromJS(item));
            }
            if (Array.isArray(_data["devices"])) {
                this.devices = [] as any;
                for (let item of _data["devices"])
                    this.devices!.push(Device.fromJS(item));
            }
            if (Array.isArray(_data["requestsPendings"])) {
                this.requestsPendings = [] as any;
                for (let item of _data["requestsPendings"])
                    this.requestsPendings!.push(RequestsPending.fromJS(item));
            }
            if (Array.isArray(_data["requestsReceipteds"])) {
                this.requestsReceipteds = [] as any;
                for (let item of _data["requestsReceipteds"])
                    this.requestsReceipteds!.push(RequestsReceipted.fromJS(item));
            }
            this.company = _data["company"] ? Company.fromJS(_data["company"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Store {
        data = typeof data === 'object' ? data : {};
        let result = new Store();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["storeCode"] = this.storeCode;
        data["storeName"] = this.storeName;
        data["companyId"] = this.companyId;
        data["normalizedStoreName"] = this.normalizedStoreName;
        data["order"] = this.order;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.cards)) {
            data["cards"] = [];
            for (let item of this.cards)
                data["cards"].push(item.toJSON());
        }
        if (Array.isArray(this.devices)) {
            data["devices"] = [];
            for (let item of this.devices)
                data["devices"].push(item.toJSON());
        }
        if (Array.isArray(this.requestsPendings)) {
            data["requestsPendings"] = [];
            for (let item of this.requestsPendings)
                data["requestsPendings"].push(item.toJSON());
        }
        if (Array.isArray(this.requestsReceipteds)) {
            data["requestsReceipteds"] = [];
            for (let item of this.requestsReceipteds)
                data["requestsReceipteds"].push(item.toJSON());
        }
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IStore extends IAuditableEntity {
    id?: number;
    storeCode?: string | undefined;
    storeName?: string | undefined;
    companyId?: number;
    normalizedStoreName?: string | undefined;
    order?: number;
    isActive?: boolean;
    cards?: Card[] | undefined;
    devices?: Device[] | undefined;
    requestsPendings?: RequestsPending[] | undefined;
    requestsReceipteds?: RequestsReceipted[] | undefined;
    company?: Company | undefined;
}

export class Card extends AuditableEntity implements ICard {
    id?: number;
    no?: number;
    memberNo?: string | undefined;
    status?: CardStatus;
    point?: string | undefined;
    storeId?: number | undefined;
    companyId?: number | undefined;
    expiredAt?: Date;
    store?: Store | undefined;
    company?: Company | undefined;

    constructor(data?: ICard) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.no = _data["no"];
            this.memberNo = _data["memberNo"];
            this.status = _data["status"];
            this.point = _data["point"];
            this.storeId = _data["storeId"];
            this.companyId = _data["companyId"];
            this.expiredAt = _data["expiredAt"] ? new Date(_data["expiredAt"].toString()) : <any>undefined;
            this.store = _data["store"] ? Store.fromJS(_data["store"]) : <any>undefined;
            this.company = _data["company"] ? Company.fromJS(_data["company"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Card {
        data = typeof data === 'object' ? data : {};
        let result = new Card();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["no"] = this.no;
        data["memberNo"] = this.memberNo;
        data["status"] = this.status;
        data["point"] = this.point;
        data["storeId"] = this.storeId;
        data["companyId"] = this.companyId;
        data["expiredAt"] = this.expiredAt ? this.expiredAt.toISOString() : <any>undefined;
        data["store"] = this.store ? this.store.toJSON() : <any>undefined;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface ICard extends IAuditableEntity {
    id?: number;
    no?: number;
    memberNo?: string | undefined;
    status?: CardStatus;
    point?: string | undefined;
    storeId?: number | undefined;
    companyId?: number | undefined;
    expiredAt?: Date;
    store?: Store | undefined;
    company?: Company | undefined;
}

export class Company extends AuditableEntity implements ICompany {
    id?: number;
    companyCode?: string | undefined;
    companyName?: string | undefined;
    normalizedCompanyName?: string | undefined;
    order?: number;
    isActive?: boolean;
    cards?: Card[] | undefined;
    stores?: Store[] | undefined;

    constructor(data?: ICompany) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.companyCode = _data["companyCode"];
            this.companyName = _data["companyName"];
            this.normalizedCompanyName = _data["normalizedCompanyName"];
            this.order = _data["order"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["cards"])) {
                this.cards = [] as any;
                for (let item of _data["cards"])
                    this.cards!.push(Card.fromJS(item));
            }
            if (Array.isArray(_data["stores"])) {
                this.stores = [] as any;
                for (let item of _data["stores"])
                    this.stores!.push(Store.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Company {
        data = typeof data === 'object' ? data : {};
        let result = new Company();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyCode"] = this.companyCode;
        data["companyName"] = this.companyName;
        data["normalizedCompanyName"] = this.normalizedCompanyName;
        data["order"] = this.order;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.cards)) {
            data["cards"] = [];
            for (let item of this.cards)
                data["cards"].push(item.toJSON());
        }
        if (Array.isArray(this.stores)) {
            data["stores"] = [];
            for (let item of this.stores)
                data["stores"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface ICompany extends IAuditableEntity {
    id?: number;
    companyCode?: string | undefined;
    companyName?: string | undefined;
    normalizedCompanyName?: string | undefined;
    order?: number;
    isActive?: boolean;
    cards?: Card[] | undefined;
    stores?: Store[] | undefined;
}

export class Device extends AuditableEntity implements IDevice {
    id?: number;
    deviceCode?: string | undefined;
    storeId?: number;
    isActive?: boolean;
    isAutoLock?: boolean;
    lat?: string | undefined;
    long?: string | undefined;
    store?: Store | undefined;

    constructor(data?: IDevice) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.deviceCode = _data["deviceCode"];
            this.storeId = _data["storeId"];
            this.isActive = _data["isActive"];
            this.isAutoLock = _data["isAutoLock"];
            this.lat = _data["lat"];
            this.long = _data["long"];
            this.store = _data["store"] ? Store.fromJS(_data["store"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Device {
        data = typeof data === 'object' ? data : {};
        let result = new Device();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["deviceCode"] = this.deviceCode;
        data["storeId"] = this.storeId;
        data["isActive"] = this.isActive;
        data["isAutoLock"] = this.isAutoLock;
        data["lat"] = this.lat;
        data["long"] = this.long;
        data["store"] = this.store ? this.store.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IDevice extends IAuditableEntity {
    id?: number;
    deviceCode?: string | undefined;
    storeId?: number;
    isActive?: boolean;
    isAutoLock?: boolean;
    lat?: string | undefined;
    long?: string | undefined;
    store?: Store | undefined;
}

export class RequestsPending extends AuditableEntity implements IRequestsPending {
    id?: number;
    receiptedDatetime?: Date;
    requestCode?: string | undefined;
    deviceId?: number | undefined;
    memberId?: number | undefined;
    storeId?: number | undefined;
    store?: Store | undefined;
    device?: Device | undefined;
    member?: Member | undefined;

    constructor(data?: IRequestsPending) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.receiptedDatetime = _data["receiptedDatetime"] ? new Date(_data["receiptedDatetime"].toString()) : <any>undefined;
            this.requestCode = _data["requestCode"];
            this.deviceId = _data["deviceId"];
            this.memberId = _data["memberId"];
            this.storeId = _data["storeId"];
            this.store = _data["store"] ? Store.fromJS(_data["store"]) : <any>undefined;
            this.device = _data["device"] ? Device.fromJS(_data["device"]) : <any>undefined;
            this.member = _data["member"] ? Member.fromJS(_data["member"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RequestsPending {
        data = typeof data === 'object' ? data : {};
        let result = new RequestsPending();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["receiptedDatetime"] = this.receiptedDatetime ? this.receiptedDatetime.toISOString() : <any>undefined;
        data["requestCode"] = this.requestCode;
        data["deviceId"] = this.deviceId;
        data["memberId"] = this.memberId;
        data["storeId"] = this.storeId;
        data["store"] = this.store ? this.store.toJSON() : <any>undefined;
        data["device"] = this.device ? this.device.toJSON() : <any>undefined;
        data["member"] = this.member ? this.member.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IRequestsPending extends IAuditableEntity {
    id?: number;
    receiptedDatetime?: Date;
    requestCode?: string | undefined;
    deviceId?: number | undefined;
    memberId?: number | undefined;
    storeId?: number | undefined;
    store?: Store | undefined;
    device?: Device | undefined;
    member?: Member | undefined;
}

export class Member extends AuditableEntity implements IMember {
    id?: number;
    memberNo?: string | undefined;
    oldMemberNo?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    furiganaFirstName?: string | undefined;
    furiganaLastName?: string | undefined;
    isNetMember?: boolean;
    dateOfBirth?: Date | undefined;
    fixedPhone?: string | undefined;
    mobilePhone?: string | undefined;
    email?: string | undefined;
    remark?: string | undefined;
    picStoreId?: number | undefined;
    province?: string | undefined;
    district?: string | undefined;
    street?: string | undefined;
    buildingName?: string | undefined;
    isRegisterAdvertisement?: boolean;
    zipcodeId?: string | undefined;
    isUpdateInformation?: boolean;
    isRegisterKidClub?: boolean;
    isAgreeGetOutMember?: boolean;
    sex?: SexType;
    memberKids?: MemberKid[] | undefined;
    picStore?: PICStore | undefined;
    requestsReceipteds?: RequestsReceipted[] | undefined;
    requestsPendings?: RequestsPending[] | undefined;

    constructor(data?: IMember) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.memberNo = _data["memberNo"];
            this.oldMemberNo = _data["oldMemberNo"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.furiganaFirstName = _data["furiganaFirstName"];
            this.furiganaLastName = _data["furiganaLastName"];
            this.isNetMember = _data["isNetMember"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.fixedPhone = _data["fixedPhone"];
            this.mobilePhone = _data["mobilePhone"];
            this.email = _data["email"];
            this.remark = _data["remark"];
            this.picStoreId = _data["picStoreId"];
            this.province = _data["province"];
            this.district = _data["district"];
            this.street = _data["street"];
            this.buildingName = _data["buildingName"];
            this.isRegisterAdvertisement = _data["isRegisterAdvertisement"];
            this.zipcodeId = _data["zipcodeId"];
            this.isUpdateInformation = _data["isUpdateInformation"];
            this.isRegisterKidClub = _data["isRegisterKidClub"];
            this.isAgreeGetOutMember = _data["isAgreeGetOutMember"];
            this.sex = _data["sex"];
            if (Array.isArray(_data["memberKids"])) {
                this.memberKids = [] as any;
                for (let item of _data["memberKids"])
                    this.memberKids!.push(MemberKid.fromJS(item));
            }
            this.picStore = _data["picStore"] ? PICStore.fromJS(_data["picStore"]) : <any>undefined;
            if (Array.isArray(_data["requestsReceipteds"])) {
                this.requestsReceipteds = [] as any;
                for (let item of _data["requestsReceipteds"])
                    this.requestsReceipteds!.push(RequestsReceipted.fromJS(item));
            }
            if (Array.isArray(_data["requestsPendings"])) {
                this.requestsPendings = [] as any;
                for (let item of _data["requestsPendings"])
                    this.requestsPendings!.push(RequestsPending.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Member {
        data = typeof data === 'object' ? data : {};
        let result = new Member();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["memberNo"] = this.memberNo;
        data["oldMemberNo"] = this.oldMemberNo;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["furiganaFirstName"] = this.furiganaFirstName;
        data["furiganaLastName"] = this.furiganaLastName;
        data["isNetMember"] = this.isNetMember;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["fixedPhone"] = this.fixedPhone;
        data["mobilePhone"] = this.mobilePhone;
        data["email"] = this.email;
        data["remark"] = this.remark;
        data["picStoreId"] = this.picStoreId;
        data["province"] = this.province;
        data["district"] = this.district;
        data["street"] = this.street;
        data["buildingName"] = this.buildingName;
        data["isRegisterAdvertisement"] = this.isRegisterAdvertisement;
        data["zipcodeId"] = this.zipcodeId;
        data["isUpdateInformation"] = this.isUpdateInformation;
        data["isRegisterKidClub"] = this.isRegisterKidClub;
        data["isAgreeGetOutMember"] = this.isAgreeGetOutMember;
        data["sex"] = this.sex;
        if (Array.isArray(this.memberKids)) {
            data["memberKids"] = [];
            for (let item of this.memberKids)
                data["memberKids"].push(item.toJSON());
        }
        data["picStore"] = this.picStore ? this.picStore.toJSON() : <any>undefined;
        if (Array.isArray(this.requestsReceipteds)) {
            data["requestsReceipteds"] = [];
            for (let item of this.requestsReceipteds)
                data["requestsReceipteds"].push(item.toJSON());
        }
        if (Array.isArray(this.requestsPendings)) {
            data["requestsPendings"] = [];
            for (let item of this.requestsPendings)
                data["requestsPendings"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IMember extends IAuditableEntity {
    id?: number;
    memberNo?: string | undefined;
    oldMemberNo?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    furiganaFirstName?: string | undefined;
    furiganaLastName?: string | undefined;
    isNetMember?: boolean;
    dateOfBirth?: Date | undefined;
    fixedPhone?: string | undefined;
    mobilePhone?: string | undefined;
    email?: string | undefined;
    remark?: string | undefined;
    picStoreId?: number | undefined;
    province?: string | undefined;
    district?: string | undefined;
    street?: string | undefined;
    buildingName?: string | undefined;
    isRegisterAdvertisement?: boolean;
    zipcodeId?: string | undefined;
    isUpdateInformation?: boolean;
    isRegisterKidClub?: boolean;
    isAgreeGetOutMember?: boolean;
    sex?: SexType;
    memberKids?: MemberKid[] | undefined;
    picStore?: PICStore | undefined;
    requestsReceipteds?: RequestsReceipted[] | undefined;
    requestsPendings?: RequestsPending[] | undefined;
}

export enum SexType {
    Male = 1,
    Female = 2,
    Other = 3,
}

export class MemberKid extends AuditableEntity implements IMemberKid {
    id?: number;
    parentFirstName?: string | undefined;
    parentLastName?: string | undefined;
    parentFuriganaFirstName?: string | undefined;
    parentFuriganaLastName?: string | undefined;
    relationshipMember?: number;
    firstName?: string | undefined;
    lastName?: string | undefined;
    furiganaFirstName?: string | undefined;
    furiganaLastName?: string | undefined;
    sex?: number;
    isLivingWithParent?: boolean;
    remark?: string | undefined;
    dateOfBirth?: Date;
    member?: Member | undefined;

    constructor(data?: IMemberKid) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.parentFirstName = _data["parentFirstName"];
            this.parentLastName = _data["parentLastName"];
            this.parentFuriganaFirstName = _data["parentFuriganaFirstName"];
            this.parentFuriganaLastName = _data["parentFuriganaLastName"];
            this.relationshipMember = _data["relationshipMember"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.furiganaFirstName = _data["furiganaFirstName"];
            this.furiganaLastName = _data["furiganaLastName"];
            this.sex = _data["sex"];
            this.isLivingWithParent = _data["isLivingWithParent"];
            this.remark = _data["remark"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.member = _data["member"] ? Member.fromJS(_data["member"]) : <any>undefined;
        }
    }

    static fromJS(data: any): MemberKid {
        data = typeof data === 'object' ? data : {};
        let result = new MemberKid();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["parentFirstName"] = this.parentFirstName;
        data["parentLastName"] = this.parentLastName;
        data["parentFuriganaFirstName"] = this.parentFuriganaFirstName;
        data["parentFuriganaLastName"] = this.parentFuriganaLastName;
        data["relationshipMember"] = this.relationshipMember;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["furiganaFirstName"] = this.furiganaFirstName;
        data["furiganaLastName"] = this.furiganaLastName;
        data["sex"] = this.sex;
        data["isLivingWithParent"] = this.isLivingWithParent;
        data["remark"] = this.remark;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["member"] = this.member ? this.member.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IMemberKid extends IAuditableEntity {
    id?: number;
    parentFirstName?: string | undefined;
    parentLastName?: string | undefined;
    parentFuriganaFirstName?: string | undefined;
    parentFuriganaLastName?: string | undefined;
    relationshipMember?: number;
    firstName?: string | undefined;
    lastName?: string | undefined;
    furiganaFirstName?: string | undefined;
    furiganaLastName?: string | undefined;
    sex?: number;
    isLivingWithParent?: boolean;
    remark?: string | undefined;
    dateOfBirth?: Date;
    member?: Member | undefined;
}

export class PICStore extends AuditableEntity implements IPICStore {
    id?: number;
    picCode!: string;
    picName?: string | undefined;
    requestsPendings?: RequestsPending[] | undefined;
    members?: Member[] | undefined;

    constructor(data?: IPICStore) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.picCode = _data["picCode"];
            this.picName = _data["picName"];
            if (Array.isArray(_data["requestsPendings"])) {
                this.requestsPendings = [] as any;
                for (let item of _data["requestsPendings"])
                    this.requestsPendings!.push(RequestsPending.fromJS(item));
            }
            if (Array.isArray(_data["members"])) {
                this.members = [] as any;
                for (let item of _data["members"])
                    this.members!.push(Member.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PICStore {
        data = typeof data === 'object' ? data : {};
        let result = new PICStore();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["picCode"] = this.picCode;
        data["picName"] = this.picName;
        if (Array.isArray(this.requestsPendings)) {
            data["requestsPendings"] = [];
            for (let item of this.requestsPendings)
                data["requestsPendings"].push(item.toJSON());
        }
        if (Array.isArray(this.members)) {
            data["members"] = [];
            for (let item of this.members)
                data["members"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IPICStore extends IAuditableEntity {
    id?: number;
    picCode: string;
    picName?: string | undefined;
    requestsPendings?: RequestsPending[] | undefined;
    members?: Member[] | undefined;
}

export class RequestsReceipted extends AuditableEntity implements IRequestsReceipted {
    id?: number;
    cardId?: number | undefined;
    receiptedDatetime?: Date;
    receiptedTypeId?: number;
    deviceId?: number | undefined;
    memberId?: number | undefined;
    requestCode?: string | undefined;
    storeId?: number | undefined;
    receiptedTypeDetail?: RequestTypeDetail | undefined;
    store?: Store | undefined;
    device?: Device | undefined;
    member?: Member | undefined;
    requestType?: RequestType | undefined;

    constructor(data?: IRequestsReceipted) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.cardId = _data["cardId"];
            this.receiptedDatetime = _data["receiptedDatetime"] ? new Date(_data["receiptedDatetime"].toString()) : <any>undefined;
            this.receiptedTypeId = _data["receiptedTypeId"];
            this.deviceId = _data["deviceId"];
            this.memberId = _data["memberId"];
            this.requestCode = _data["requestCode"];
            this.storeId = _data["storeId"];
            this.receiptedTypeDetail = _data["receiptedTypeDetail"];
            this.store = _data["store"] ? Store.fromJS(_data["store"]) : <any>undefined;
            this.device = _data["device"] ? Device.fromJS(_data["device"]) : <any>undefined;
            this.member = _data["member"] ? Member.fromJS(_data["member"]) : <any>undefined;
            this.requestType = _data["requestType"] ? RequestType.fromJS(_data["requestType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RequestsReceipted {
        data = typeof data === 'object' ? data : {};
        let result = new RequestsReceipted();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["cardId"] = this.cardId;
        data["receiptedDatetime"] = this.receiptedDatetime ? this.receiptedDatetime.toISOString() : <any>undefined;
        data["receiptedTypeId"] = this.receiptedTypeId;
        data["deviceId"] = this.deviceId;
        data["memberId"] = this.memberId;
        data["requestCode"] = this.requestCode;
        data["storeId"] = this.storeId;
        data["receiptedTypeDetail"] = this.receiptedTypeDetail;
        data["store"] = this.store ? this.store.toJSON() : <any>undefined;
        data["device"] = this.device ? this.device.toJSON() : <any>undefined;
        data["member"] = this.member ? this.member.toJSON() : <any>undefined;
        data["requestType"] = this.requestType ? this.requestType.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IRequestsReceipted extends IAuditableEntity {
    id?: number;
    cardId?: number | undefined;
    receiptedDatetime?: Date;
    receiptedTypeId?: number;
    deviceId?: number | undefined;
    memberId?: number | undefined;
    requestCode?: string | undefined;
    storeId?: number | undefined;
    receiptedTypeDetail?: RequestTypeDetail | undefined;
    store?: Store | undefined;
    device?: Device | undefined;
    member?: Member | undefined;
    requestType?: RequestType | undefined;
}

export enum RequestTypeDetail {
    Unset = 0,
    SwitchCard_PointToPrepaid = 1,
    SwitchCard_MagneticFailure = 2,
    SwitchCard_ExpirationDateRenewal = 3,
    ReIssue_PointCard = 4,
    ReIssue_PrepaidCard = 5,
}

export class RequestType extends AuditableEntity implements IRequestType {
    id?: number;
    requestTypeCode?: string | undefined;
    requestTypeName?: string | undefined;
    requestsReceipteds?: RequestsReceipted[] | undefined;

    constructor(data?: IRequestType) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.requestTypeCode = _data["requestTypeCode"];
            this.requestTypeName = _data["requestTypeName"];
            if (Array.isArray(_data["requestsReceipteds"])) {
                this.requestsReceipteds = [] as any;
                for (let item of _data["requestsReceipteds"])
                    this.requestsReceipteds!.push(RequestsReceipted.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RequestType {
        data = typeof data === 'object' ? data : {};
        let result = new RequestType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["requestTypeCode"] = this.requestTypeCode;
        data["requestTypeName"] = this.requestTypeName;
        if (Array.isArray(this.requestsReceipteds)) {
            data["requestsReceipteds"] = [];
            for (let item of this.requestsReceipteds)
                data["requestsReceipteds"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IRequestType extends IAuditableEntity {
    id?: number;
    requestTypeCode?: string | undefined;
    requestTypeName?: string | undefined;
    requestsReceipteds?: RequestsReceipted[] | undefined;
}

export class ApplicationUserDto implements IApplicationUserDto {
    id?: string | undefined;
    userName?: string | undefined;
    email?: string | undefined;
    storeId?: number | undefined;
    webSessionTimeout?: number | undefined;
    appSessionTimeout?: number | undefined;
    distanceOfAppLocking?: number | undefined;
    rolePermission?: any | undefined;
    companyId?: number | undefined;
    fullName?: string | undefined;

    constructor(data?: IApplicationUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.storeId = _data["storeId"];
            this.webSessionTimeout = _data["webSessionTimeout"];
            this.appSessionTimeout = _data["appSessionTimeout"];
            this.distanceOfAppLocking = _data["distanceOfAppLocking"];
            this.rolePermission = _data["rolePermission"];
            this.companyId = _data["companyId"];
            this.fullName = _data["fullName"];
        }
    }

    static fromJS(data: any): ApplicationUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["storeId"] = this.storeId;
        data["webSessionTimeout"] = this.webSessionTimeout;
        data["appSessionTimeout"] = this.appSessionTimeout;
        data["distanceOfAppLocking"] = this.distanceOfAppLocking;
        data["rolePermission"] = this.rolePermission;
        data["companyId"] = this.companyId;
        data["fullName"] = this.fullName;
        return data; 
    }
}

export interface IApplicationUserDto {
    id?: string | undefined;
    userName?: string | undefined;
    email?: string | undefined;
    storeId?: number | undefined;
    webSessionTimeout?: number | undefined;
    appSessionTimeout?: number | undefined;
    distanceOfAppLocking?: number | undefined;
    rolePermission?: any | undefined;
    companyId?: number | undefined;
    fullName?: string | undefined;
}

export class UpdateCardsCommand implements IUpdateCardsCommand {
    cardsUpdate?: CardDto[] | undefined;

    constructor(data?: IUpdateCardsCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["cardsUpdate"])) {
                this.cardsUpdate = [] as any;
                for (let item of _data["cardsUpdate"])
                    this.cardsUpdate!.push(CardDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateCardsCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCardsCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.cardsUpdate)) {
            data["cardsUpdate"] = [];
            for (let item of this.cardsUpdate)
                data["cardsUpdate"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUpdateCardsCommand {
    cardsUpdate?: CardDto[] | undefined;
}

export class DeleteCardsCommand implements IDeleteCardsCommand {
    cardsDelete?: CardDto[] | undefined;

    constructor(data?: IDeleteCardsCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["cardsDelete"])) {
                this.cardsDelete = [] as any;
                for (let item of _data["cardsDelete"])
                    this.cardsDelete!.push(CardDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DeleteCardsCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteCardsCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.cardsDelete)) {
            data["cardsDelete"] = [];
            for (let item of this.cardsDelete)
                data["cardsDelete"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IDeleteCardsCommand {
    cardsDelete?: CardDto[] | undefined;
}

export class AddPendingRequestListCommand implements IAddPendingRequestListCommand {
    memberNo?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    furiganaFirstName?: string | undefined;
    furiganaLastName?: string | undefined;
    sex?: SexType;
    zipcodeId?: string | undefined;
    province?: string | undefined;
    district?: string | undefined;
    street?: string | undefined;
    isRegisterAdvertisement?: boolean;
    dateOfBirth?: Date;
    fixedPhone?: string | undefined;
    mobilePhone?: string | undefined;
    email?: string | undefined;
    buildingName?: string | undefined;
    receiptedDatetime?: Date;
    storeId?: number | undefined;
    deviceId?: number;
    picStoreId?: number | undefined;
    gmt?: number;

    constructor(data?: IAddPendingRequestListCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberNo = _data["memberNo"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.furiganaFirstName = _data["furiganaFirstName"];
            this.furiganaLastName = _data["furiganaLastName"];
            this.sex = _data["sex"];
            this.zipcodeId = _data["zipcodeId"];
            this.province = _data["province"];
            this.district = _data["district"];
            this.street = _data["street"];
            this.isRegisterAdvertisement = _data["isRegisterAdvertisement"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.fixedPhone = _data["fixedPhone"];
            this.mobilePhone = _data["mobilePhone"];
            this.email = _data["email"];
            this.buildingName = _data["buildingName"];
            this.receiptedDatetime = _data["receiptedDatetime"] ? new Date(_data["receiptedDatetime"].toString()) : <any>undefined;
            this.storeId = _data["storeId"];
            this.deviceId = _data["deviceId"];
            this.picStoreId = _data["picStoreId"];
            this.gmt = _data["gmt"];
        }
    }

    static fromJS(data: any): AddPendingRequestListCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AddPendingRequestListCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberNo"] = this.memberNo;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["furiganaFirstName"] = this.furiganaFirstName;
        data["furiganaLastName"] = this.furiganaLastName;
        data["sex"] = this.sex;
        data["zipcodeId"] = this.zipcodeId;
        data["province"] = this.province;
        data["district"] = this.district;
        data["street"] = this.street;
        data["isRegisterAdvertisement"] = this.isRegisterAdvertisement;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["fixedPhone"] = this.fixedPhone;
        data["mobilePhone"] = this.mobilePhone;
        data["email"] = this.email;
        data["buildingName"] = this.buildingName;
        data["receiptedDatetime"] = this.receiptedDatetime ? this.receiptedDatetime.toISOString() : <any>undefined;
        data["storeId"] = this.storeId;
        data["deviceId"] = this.deviceId;
        data["picStoreId"] = this.picStoreId;
        data["gmt"] = this.gmt;
        return data; 
    }
}

export interface IAddPendingRequestListCommand {
    memberNo?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    furiganaFirstName?: string | undefined;
    furiganaLastName?: string | undefined;
    sex?: SexType;
    zipcodeId?: string | undefined;
    province?: string | undefined;
    district?: string | undefined;
    street?: string | undefined;
    isRegisterAdvertisement?: boolean;
    dateOfBirth?: Date;
    fixedPhone?: string | undefined;
    mobilePhone?: string | undefined;
    email?: string | undefined;
    buildingName?: string | undefined;
    receiptedDatetime?: Date;
    storeId?: number | undefined;
    deviceId?: number;
    picStoreId?: number | undefined;
    gmt?: number;
}

export class PaginatedListOfPendingRequestListDto implements IPaginatedListOfPendingRequestListDto {
    items?: PendingRequestListDto[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfPendingRequestListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PendingRequestListDto.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfPendingRequestListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfPendingRequestListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data; 
    }
}

export interface IPaginatedListOfPendingRequestListDto {
    items?: PendingRequestListDto[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class PendingRequestListDto implements IPendingRequestListDto {
    id?: number;
    createdAt?: Date;
    requestType?: string | undefined;
    memberNo?: string | undefined;
    oldMemberNo?: string | undefined;
    customerName?: string | undefined;
    customerFirstName?: string | undefined;
    customerLastName?: string | undefined;
    picName?: string | undefined;
    remark?: string | undefined;

    constructor(data?: IPendingRequestListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.requestType = _data["requestType"];
            this.memberNo = _data["memberNo"];
            this.oldMemberNo = _data["oldMemberNo"];
            this.customerName = _data["customerName"];
            this.customerFirstName = _data["customerFirstName"];
            this.customerLastName = _data["customerLastName"];
            this.picName = _data["picName"];
            this.remark = _data["remark"];
        }
    }

    static fromJS(data: any): PendingRequestListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PendingRequestListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["requestType"] = this.requestType;
        data["memberNo"] = this.memberNo;
        data["oldMemberNo"] = this.oldMemberNo;
        data["customerName"] = this.customerName;
        data["customerFirstName"] = this.customerFirstName;
        data["customerLastName"] = this.customerLastName;
        data["picName"] = this.picName;
        data["remark"] = this.remark;
        return data; 
    }
}

export interface IPendingRequestListDto {
    id?: number;
    createdAt?: Date;
    requestType?: string | undefined;
    memberNo?: string | undefined;
    oldMemberNo?: string | undefined;
    customerName?: string | undefined;
    customerFirstName?: string | undefined;
    customerLastName?: string | undefined;
    picName?: string | undefined;
    remark?: string | undefined;
}

export class PendingRequestDetailDto implements IPendingRequestDetailDto {
    id?: number;
    memberNo?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    furiganaFirstName?: string | undefined;
    furiganaLastName?: string | undefined;
    sex?: SexType;
    zipcodeId?: string | undefined;
    province?: string | undefined;
    district?: string | undefined;
    street?: string | undefined;
    isRegisterAdvertisement?: boolean;
    dateOfBirth?: Date;
    fixedPhone?: string | undefined;
    mobilePhone?: string | undefined;
    email?: string | undefined;
    buildingName?: string | undefined;
    receiptedDatetime?: Date;
    storeId?: number | undefined;
    deviceCode?: string | undefined;
    picStoreId?: number | undefined;

    constructor(data?: IPendingRequestDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.memberNo = _data["memberNo"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.furiganaFirstName = _data["furiganaFirstName"];
            this.furiganaLastName = _data["furiganaLastName"];
            this.sex = _data["sex"];
            this.zipcodeId = _data["zipcodeId"];
            this.province = _data["province"];
            this.district = _data["district"];
            this.street = _data["street"];
            this.isRegisterAdvertisement = _data["isRegisterAdvertisement"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.fixedPhone = _data["fixedPhone"];
            this.mobilePhone = _data["mobilePhone"];
            this.email = _data["email"];
            this.buildingName = _data["buildingName"];
            this.receiptedDatetime = _data["receiptedDatetime"] ? new Date(_data["receiptedDatetime"].toString()) : <any>undefined;
            this.storeId = _data["storeId"];
            this.deviceCode = _data["deviceCode"];
            this.picStoreId = _data["picStoreId"];
        }
    }

    static fromJS(data: any): PendingRequestDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new PendingRequestDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["memberNo"] = this.memberNo;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["furiganaFirstName"] = this.furiganaFirstName;
        data["furiganaLastName"] = this.furiganaLastName;
        data["sex"] = this.sex;
        data["zipcodeId"] = this.zipcodeId;
        data["province"] = this.province;
        data["district"] = this.district;
        data["street"] = this.street;
        data["isRegisterAdvertisement"] = this.isRegisterAdvertisement;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["fixedPhone"] = this.fixedPhone;
        data["mobilePhone"] = this.mobilePhone;
        data["email"] = this.email;
        data["buildingName"] = this.buildingName;
        data["receiptedDatetime"] = this.receiptedDatetime ? this.receiptedDatetime.toISOString() : <any>undefined;
        data["storeId"] = this.storeId;
        data["deviceCode"] = this.deviceCode;
        data["picStoreId"] = this.picStoreId;
        return data; 
    }
}

export interface IPendingRequestDetailDto {
    id?: number;
    memberNo?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    furiganaFirstName?: string | undefined;
    furiganaLastName?: string | undefined;
    sex?: SexType;
    zipcodeId?: string | undefined;
    province?: string | undefined;
    district?: string | undefined;
    street?: string | undefined;
    isRegisterAdvertisement?: boolean;
    dateOfBirth?: Date;
    fixedPhone?: string | undefined;
    mobilePhone?: string | undefined;
    email?: string | undefined;
    buildingName?: string | undefined;
    receiptedDatetime?: Date;
    storeId?: number | undefined;
    deviceCode?: string | undefined;
    picStoreId?: number | undefined;
}

export class ConfirmPendingRequestCommand implements IConfirmPendingRequestCommand {
    pendingId?: number;
    oldMemberNo?: string | undefined;
    receiptedDatetime?: Date;
    storeId?: number | undefined;
    deviceId?: number | undefined;
    picStoreId?: number | undefined;

    constructor(data?: IConfirmPendingRequestCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pendingId = _data["pendingId"];
            this.oldMemberNo = _data["oldMemberNo"];
            this.receiptedDatetime = _data["receiptedDatetime"] ? new Date(_data["receiptedDatetime"].toString()) : <any>undefined;
            this.storeId = _data["storeId"];
            this.deviceId = _data["deviceId"];
            this.picStoreId = _data["picStoreId"];
        }
    }

    static fromJS(data: any): ConfirmPendingRequestCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ConfirmPendingRequestCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pendingId"] = this.pendingId;
        data["oldMemberNo"] = this.oldMemberNo;
        data["receiptedDatetime"] = this.receiptedDatetime ? this.receiptedDatetime.toISOString() : <any>undefined;
        data["storeId"] = this.storeId;
        data["deviceId"] = this.deviceId;
        data["picStoreId"] = this.picStoreId;
        return data; 
    }
}

export interface IConfirmPendingRequestCommand {
    pendingId?: number;
    oldMemberNo?: string | undefined;
    receiptedDatetime?: Date;
    storeId?: number | undefined;
    deviceId?: number | undefined;
    picStoreId?: number | undefined;
}

export class RequestTypeDto implements IRequestTypeDto {
    id?: number;
    requestTypeName?: string | undefined;

    constructor(data?: IRequestTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.requestTypeName = _data["requestTypeName"];
        }
    }

    static fromJS(data: any): RequestTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new RequestTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["requestTypeName"] = this.requestTypeName;
        return data; 
    }
}

export interface IRequestTypeDto {
    id?: number;
    requestTypeName?: string | undefined;
}

export class PaginatedListOfCardDto implements IPaginatedListOfCardDto {
    items?: CardDto[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfCardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CardDto.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfCardDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfCardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data; 
    }
}

export interface IPaginatedListOfCardDto {
    items?: CardDto[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class AddMigrateRequestCommand implements IAddMigrateRequestCommand {
    oldMemberNo?: string | undefined;
    memberNo?: string | undefined;
    storeId?: number;
    deviceId?: number;
    gmt?: number;

    constructor(data?: IAddMigrateRequestCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.oldMemberNo = _data["oldMemberNo"];
            this.memberNo = _data["memberNo"];
            this.storeId = _data["storeId"];
            this.deviceId = _data["deviceId"];
            this.gmt = _data["gmt"];
        }
    }

    static fromJS(data: any): AddMigrateRequestCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AddMigrateRequestCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["oldMemberNo"] = this.oldMemberNo;
        data["memberNo"] = this.memberNo;
        data["storeId"] = this.storeId;
        data["deviceId"] = this.deviceId;
        data["gmt"] = this.gmt;
        return data; 
    }
}

export interface IAddMigrateRequestCommand {
    oldMemberNo?: string | undefined;
    memberNo?: string | undefined;
    storeId?: number;
    deviceId?: number;
    gmt?: number;
}

export class PaginatedListOfPrepaidCardDto implements IPaginatedListOfPrepaidCardDto {
    items?: PrepaidCardDto[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfPrepaidCardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PrepaidCardDto.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfPrepaidCardDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfPrepaidCardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data; 
    }
}

export interface IPaginatedListOfPrepaidCardDto {
    items?: PrepaidCardDto[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class PrepaidCardDto implements IPrepaidCardDto {
    id?: number;
    no?: number;
    memberNo?: string | undefined;
    receiptedDatetime?: Date | undefined;
    status?: string | undefined;
    requestType?: string | undefined;
    picStore?: string | undefined;
    remark?: string | undefined;

    constructor(data?: IPrepaidCardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.no = _data["no"];
            this.memberNo = _data["memberNo"];
            this.receiptedDatetime = _data["receiptedDatetime"] ? new Date(_data["receiptedDatetime"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.requestType = _data["requestType"];
            this.picStore = _data["picStore"];
            this.remark = _data["remark"];
        }
    }

    static fromJS(data: any): PrepaidCardDto {
        data = typeof data === 'object' ? data : {};
        let result = new PrepaidCardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["no"] = this.no;
        data["memberNo"] = this.memberNo;
        data["receiptedDatetime"] = this.receiptedDatetime ? this.receiptedDatetime.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["requestType"] = this.requestType;
        data["picStore"] = this.picStore;
        data["remark"] = this.remark;
        return data; 
    }
}

export interface IPrepaidCardDto {
    id?: number;
    no?: number;
    memberNo?: string | undefined;
    receiptedDatetime?: Date | undefined;
    status?: string | undefined;
    requestType?: string | undefined;
    picStore?: string | undefined;
    remark?: string | undefined;
}

export class PrepaidCardDetailDto implements IPrepaidCardDetailDto {
    id?: number;
    customerNo?: string | undefined;
    registeredDate?: Date | undefined;
    expiratedAt?: Date | undefined;
    status?: string | undefined;
    requestCode?: string | undefined;
    receiptedDatetime?: Date | undefined;
    requestType?: string | undefined;
    picStoreDto?: PICStoreDto | undefined;
    picStore?: number | undefined;
    remark?: string | undefined;

    constructor(data?: IPrepaidCardDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.customerNo = _data["customerNo"];
            this.registeredDate = _data["registeredDate"] ? new Date(_data["registeredDate"].toString()) : <any>undefined;
            this.expiratedAt = _data["expiratedAt"] ? new Date(_data["expiratedAt"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.requestCode = _data["requestCode"];
            this.receiptedDatetime = _data["receiptedDatetime"] ? new Date(_data["receiptedDatetime"].toString()) : <any>undefined;
            this.requestType = _data["requestType"];
            this.picStoreDto = _data["picStoreDto"] ? PICStoreDto.fromJS(_data["picStoreDto"]) : <any>undefined;
            this.picStore = _data["picStore"];
            this.remark = _data["remark"];
        }
    }

    static fromJS(data: any): PrepaidCardDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new PrepaidCardDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["customerNo"] = this.customerNo;
        data["registeredDate"] = this.registeredDate ? this.registeredDate.toISOString() : <any>undefined;
        data["expiratedAt"] = this.expiratedAt ? this.expiratedAt.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["requestCode"] = this.requestCode;
        data["receiptedDatetime"] = this.receiptedDatetime ? this.receiptedDatetime.toISOString() : <any>undefined;
        data["requestType"] = this.requestType;
        data["picStoreDto"] = this.picStoreDto ? this.picStoreDto.toJSON() : <any>undefined;
        data["picStore"] = this.picStore;
        data["remark"] = this.remark;
        return data; 
    }
}

export interface IPrepaidCardDetailDto {
    id?: number;
    customerNo?: string | undefined;
    registeredDate?: Date | undefined;
    expiratedAt?: Date | undefined;
    status?: string | undefined;
    requestCode?: string | undefined;
    receiptedDatetime?: Date | undefined;
    requestType?: string | undefined;
    picStoreDto?: PICStoreDto | undefined;
    picStore?: number | undefined;
    remark?: string | undefined;
}

export class PICStoreDto implements IPICStoreDto {
    index?: number;
    id?: number;
    picCode?: string | undefined;
    picName?: string | undefined;
    registrationDate?: Date;
    store?: string | undefined;
    normalizedStoreName?: string | undefined;
    company?: string | undefined;
    normalizedCompanyName?: string | undefined;

    constructor(data?: IPICStoreDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.index = _data["index"];
            this.id = _data["id"];
            this.picCode = _data["picCode"];
            this.picName = _data["picName"];
            this.registrationDate = _data["registrationDate"] ? new Date(_data["registrationDate"].toString()) : <any>undefined;
            this.store = _data["store"];
            this.normalizedStoreName = _data["normalizedStoreName"];
            this.company = _data["company"];
            this.normalizedCompanyName = _data["normalizedCompanyName"];
        }
    }

    static fromJS(data: any): PICStoreDto {
        data = typeof data === 'object' ? data : {};
        let result = new PICStoreDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["index"] = this.index;
        data["id"] = this.id;
        data["picCode"] = this.picCode;
        data["picName"] = this.picName;
        data["registrationDate"] = this.registrationDate ? this.registrationDate.toISOString() : <any>undefined;
        data["store"] = this.store;
        data["normalizedStoreName"] = this.normalizedStoreName;
        data["company"] = this.company;
        data["normalizedCompanyName"] = this.normalizedCompanyName;
        return data; 
    }
}

export interface IPICStoreDto {
    index?: number;
    id?: number;
    picCode?: string | undefined;
    picName?: string | undefined;
    registrationDate?: Date;
    store?: string | undefined;
    normalizedStoreName?: string | undefined;
    company?: string | undefined;
    normalizedCompanyName?: string | undefined;
}

export class PaginatedListOfCompanyDto implements IPaginatedListOfCompanyDto {
    items?: CompanyDto[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfCompanyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CompanyDto.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfCompanyDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfCompanyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data; 
    }
}

export interface IPaginatedListOfCompanyDto {
    items?: CompanyDto[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class CompanyDto implements ICompanyDto {
    id?: number;
    companyCode?: string | undefined;
    companyName?: string | undefined;
    normalizedCompanyName?: string | undefined;
    order?: number;
    isActive?: boolean;
    createdAt?: Date;
    createdBy?: string | undefined;
    updatedAt?: Date | undefined;
    updatedBy?: string | undefined;
    isDeleted?: boolean;

    constructor(data?: ICompanyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyCode = _data["companyCode"];
            this.companyName = _data["companyName"];
            this.normalizedCompanyName = _data["normalizedCompanyName"];
            this.order = _data["order"];
            this.isActive = _data["isActive"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            this.isDeleted = _data["isDeleted"];
        }
    }

    static fromJS(data: any): CompanyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyCode"] = this.companyCode;
        data["companyName"] = this.companyName;
        data["normalizedCompanyName"] = this.normalizedCompanyName;
        data["order"] = this.order;
        data["isActive"] = this.isActive;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        data["isDeleted"] = this.isDeleted;
        return data; 
    }
}

export interface ICompanyDto {
    id?: number;
    companyCode?: string | undefined;
    companyName?: string | undefined;
    normalizedCompanyName?: string | undefined;
    order?: number;
    isActive?: boolean;
    createdAt?: Date;
    createdBy?: string | undefined;
    updatedAt?: Date | undefined;
    updatedBy?: string | undefined;
    isDeleted?: boolean;
}

export class CompaniesVm implements ICompaniesVm {
    lists?: FlatCompanyDto[] | undefined;

    constructor(data?: ICompaniesVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["lists"])) {
                this.lists = [] as any;
                for (let item of _data["lists"])
                    this.lists!.push(FlatCompanyDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CompaniesVm {
        data = typeof data === 'object' ? data : {};
        let result = new CompaniesVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.lists)) {
            data["lists"] = [];
            for (let item of this.lists)
                data["lists"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICompaniesVm {
    lists?: FlatCompanyDto[] | undefined;
}

export class CreateCompanyCommand implements ICreateCompanyCommand {
    companyCode?: string | undefined;
    companyName?: string | undefined;
    normalizedCompanyName?: string | undefined;
    order?: number;
    isActive?: boolean;

    constructor(data?: ICreateCompanyCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.companyCode = _data["companyCode"];
            this.companyName = _data["companyName"];
            this.normalizedCompanyName = _data["normalizedCompanyName"];
            this.order = _data["order"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateCompanyCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCompanyCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyCode"] = this.companyCode;
        data["companyName"] = this.companyName;
        data["normalizedCompanyName"] = this.normalizedCompanyName;
        data["order"] = this.order;
        data["isActive"] = this.isActive;
        return data; 
    }
}

export interface ICreateCompanyCommand {
    companyCode?: string | undefined;
    companyName?: string | undefined;
    normalizedCompanyName?: string | undefined;
    order?: number;
    isActive?: boolean;
}

export class UpdateCompanyCommand implements IUpdateCompanyCommand {
    id?: number;
    companyCode?: string | undefined;
    companyName?: string | undefined;
    normalizedCompanyName?: string | undefined;
    order?: number;
    isActive?: boolean;
    updatedAt?: Date | undefined;

    constructor(data?: IUpdateCompanyCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyCode = _data["companyCode"];
            this.companyName = _data["companyName"];
            this.normalizedCompanyName = _data["normalizedCompanyName"];
            this.order = _data["order"];
            this.isActive = _data["isActive"];
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateCompanyCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCompanyCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyCode"] = this.companyCode;
        data["companyName"] = this.companyName;
        data["normalizedCompanyName"] = this.normalizedCompanyName;
        data["order"] = this.order;
        data["isActive"] = this.isActive;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IUpdateCompanyCommand {
    id?: number;
    companyCode?: string | undefined;
    companyName?: string | undefined;
    normalizedCompanyName?: string | undefined;
    order?: number;
    isActive?: boolean;
    updatedAt?: Date | undefined;
}

export class DeleteCompanyCommand implements IDeleteCompanyCommand {
    id?: number;
    updatedAt?: Date | undefined;

    constructor(data?: IDeleteCompanyCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DeleteCompanyCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteCompanyCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IDeleteCompanyCommand {
    id?: number;
    updatedAt?: Date | undefined;
}

export class GetDetailCompanyDto implements IGetDetailCompanyDto {
    id?: number;
    companyCode?: string | undefined;
    companyName?: string | undefined;
    normalizedCompanyName?: string | undefined;
    order?: number;
    isActive?: boolean;
    isDeleted?: boolean;

    constructor(data?: IGetDetailCompanyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyCode = _data["companyCode"];
            this.companyName = _data["companyName"];
            this.normalizedCompanyName = _data["normalizedCompanyName"];
            this.order = _data["order"];
            this.isActive = _data["isActive"];
            this.isDeleted = _data["isDeleted"];
        }
    }

    static fromJS(data: any): GetDetailCompanyDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetDetailCompanyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyCode"] = this.companyCode;
        data["companyName"] = this.companyName;
        data["normalizedCompanyName"] = this.normalizedCompanyName;
        data["order"] = this.order;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        return data; 
    }
}

export interface IGetDetailCompanyDto {
    id?: number;
    companyCode?: string | undefined;
    companyName?: string | undefined;
    normalizedCompanyName?: string | undefined;
    order?: number;
    isActive?: boolean;
    isDeleted?: boolean;
}

export class GetDetailCompanyWithCodeDto implements IGetDetailCompanyWithCodeDto {
    id?: number;
    companyCode?: string | undefined;
    companyName?: string | undefined;

    constructor(data?: IGetDetailCompanyWithCodeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyCode = _data["companyCode"];
            this.companyName = _data["companyName"];
        }
    }

    static fromJS(data: any): GetDetailCompanyWithCodeDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetDetailCompanyWithCodeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyCode"] = this.companyCode;
        data["companyName"] = this.companyName;
        return data; 
    }
}

export interface IGetDetailCompanyWithCodeDto {
    id?: number;
    companyCode?: string | undefined;
    companyName?: string | undefined;
}

export class PaginatedListOfSearchDevicesWithPaginationDto implements IPaginatedListOfSearchDevicesWithPaginationDto {
    items?: SearchDevicesWithPaginationDto[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfSearchDevicesWithPaginationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SearchDevicesWithPaginationDto.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfSearchDevicesWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfSearchDevicesWithPaginationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data; 
    }
}

export interface IPaginatedListOfSearchDevicesWithPaginationDto {
    items?: SearchDevicesWithPaginationDto[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class SearchDevicesWithPaginationDto implements ISearchDevicesWithPaginationDto {
    id?: number;
    no?: number;
    deviceCode?: string | undefined;
    companyCode?: string | undefined;
    normalizedCompanyName?: string | undefined;
    companyName?: string | undefined;
    storeCode?: string | undefined;
    normalizedStoreName?: string | undefined;
    storeName?: string | undefined;
    createdAt?: Date;
    status?: string | undefined;
    isAutoLock?: string | undefined;

    constructor(data?: ISearchDevicesWithPaginationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.no = _data["no"];
            this.deviceCode = _data["deviceCode"];
            this.companyCode = _data["companyCode"];
            this.normalizedCompanyName = _data["normalizedCompanyName"];
            this.companyName = _data["companyName"];
            this.storeCode = _data["storeCode"];
            this.normalizedStoreName = _data["normalizedStoreName"];
            this.storeName = _data["storeName"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.isAutoLock = _data["isAutoLock"];
        }
    }

    static fromJS(data: any): SearchDevicesWithPaginationDto {
        data = typeof data === 'object' ? data : {};
        let result = new SearchDevicesWithPaginationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["no"] = this.no;
        data["deviceCode"] = this.deviceCode;
        data["companyCode"] = this.companyCode;
        data["normalizedCompanyName"] = this.normalizedCompanyName;
        data["companyName"] = this.companyName;
        data["storeCode"] = this.storeCode;
        data["normalizedStoreName"] = this.normalizedStoreName;
        data["storeName"] = this.storeName;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["isAutoLock"] = this.isAutoLock;
        return data; 
    }
}

export interface ISearchDevicesWithPaginationDto {
    id?: number;
    no?: number;
    deviceCode?: string | undefined;
    companyCode?: string | undefined;
    normalizedCompanyName?: string | undefined;
    companyName?: string | undefined;
    storeCode?: string | undefined;
    normalizedStoreName?: string | undefined;
    storeName?: string | undefined;
    createdAt?: Date;
    status?: string | undefined;
    isAutoLock?: string | undefined;
}

export class GetDeviceDto implements IGetDeviceDto {
    id?: number;
    deviceCode?: string | undefined;
    storeId?: number;
    companyId?: number;
    isActive?: boolean;
    isAutoLock?: boolean;
    lat?: string | undefined;
    long?: string | undefined;
    createdAt?: Date;
    createdByUserName?: string | undefined;
    createdByFullName?: string | undefined;
    updatedAt?: Date | undefined;
    updatedByUserName?: string | undefined;
    updatedByFullName?: string | undefined;

    constructor(data?: IGetDeviceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.deviceCode = _data["deviceCode"];
            this.storeId = _data["storeId"];
            this.companyId = _data["companyId"];
            this.isActive = _data["isActive"];
            this.isAutoLock = _data["isAutoLock"];
            this.lat = _data["lat"];
            this.long = _data["long"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.createdByUserName = _data["createdByUserName"];
            this.createdByFullName = _data["createdByFullName"];
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.updatedByUserName = _data["updatedByUserName"];
            this.updatedByFullName = _data["updatedByFullName"];
        }
    }

    static fromJS(data: any): GetDeviceDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetDeviceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["deviceCode"] = this.deviceCode;
        data["storeId"] = this.storeId;
        data["companyId"] = this.companyId;
        data["isActive"] = this.isActive;
        data["isAutoLock"] = this.isAutoLock;
        data["lat"] = this.lat;
        data["long"] = this.long;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["createdByUserName"] = this.createdByUserName;
        data["createdByFullName"] = this.createdByFullName;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["updatedByUserName"] = this.updatedByUserName;
        data["updatedByFullName"] = this.updatedByFullName;
        return data; 
    }
}

export interface IGetDeviceDto {
    id?: number;
    deviceCode?: string | undefined;
    storeId?: number;
    companyId?: number;
    isActive?: boolean;
    isAutoLock?: boolean;
    lat?: string | undefined;
    long?: string | undefined;
    createdAt?: Date;
    createdByUserName?: string | undefined;
    createdByFullName?: string | undefined;
    updatedAt?: Date | undefined;
    updatedByUserName?: string | undefined;
    updatedByFullName?: string | undefined;
}

export class CreateDeviceCommand implements ICreateDeviceCommand {
    deviceCode?: string | undefined;
    companyCode?: string | undefined;
    storeCode?: string | undefined;
    deviceStatus?: boolean;
    isAutoLock?: boolean;
    lat?: string | undefined;
    long?: string | undefined;

    constructor(data?: ICreateDeviceCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceCode = _data["deviceCode"];
            this.companyCode = _data["companyCode"];
            this.storeCode = _data["storeCode"];
            this.deviceStatus = _data["deviceStatus"];
            this.isAutoLock = _data["isAutoLock"];
            this.lat = _data["lat"];
            this.long = _data["long"];
        }
    }

    static fromJS(data: any): CreateDeviceCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDeviceCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceCode"] = this.deviceCode;
        data["companyCode"] = this.companyCode;
        data["storeCode"] = this.storeCode;
        data["deviceStatus"] = this.deviceStatus;
        data["isAutoLock"] = this.isAutoLock;
        data["lat"] = this.lat;
        data["long"] = this.long;
        return data; 
    }
}

export interface ICreateDeviceCommand {
    deviceCode?: string | undefined;
    companyCode?: string | undefined;
    storeCode?: string | undefined;
    deviceStatus?: boolean;
    isAutoLock?: boolean;
    lat?: string | undefined;
    long?: string | undefined;
}

export class DeviceDto implements IDeviceDto {
    id?: number;
    deviceCode?: string | undefined;
    storeId?: number;
    isActive?: boolean;
    isAutoLock?: boolean;
    lat?: string | undefined;
    long?: string | undefined;
    store?: StoreDto | undefined;
    company?: CompanyDto | undefined;

    constructor(data?: IDeviceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.deviceCode = _data["deviceCode"];
            this.storeId = _data["storeId"];
            this.isActive = _data["isActive"];
            this.isAutoLock = _data["isAutoLock"];
            this.lat = _data["lat"];
            this.long = _data["long"];
            this.store = _data["store"] ? StoreDto.fromJS(_data["store"]) : <any>undefined;
            this.company = _data["company"] ? CompanyDto.fromJS(_data["company"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DeviceDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["deviceCode"] = this.deviceCode;
        data["storeId"] = this.storeId;
        data["isActive"] = this.isActive;
        data["isAutoLock"] = this.isAutoLock;
        data["lat"] = this.lat;
        data["long"] = this.long;
        data["store"] = this.store ? this.store.toJSON() : <any>undefined;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IDeviceDto {
    id?: number;
    deviceCode?: string | undefined;
    storeId?: number;
    isActive?: boolean;
    isAutoLock?: boolean;
    lat?: string | undefined;
    long?: string | undefined;
    store?: StoreDto | undefined;
    company?: CompanyDto | undefined;
}

export class StoreDto implements IStoreDto {
    id?: number;
    storeCode?: string | undefined;
    storeName?: string | undefined;
    normalizedStoreName?: string | undefined;
    order?: number;
    isActive?: boolean;
    createdAt?: Date;
    createdBy?: string | undefined;
    updatedAt?: Date | undefined;
    updatedBy?: string | undefined;
    isDeleted?: boolean;
    companyId?: number;
    companyCode?: string | undefined;
    companyName?: string | undefined;

    constructor(data?: IStoreDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.storeCode = _data["storeCode"];
            this.storeName = _data["storeName"];
            this.normalizedStoreName = _data["normalizedStoreName"];
            this.order = _data["order"];
            this.isActive = _data["isActive"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.updatedBy = _data["updatedBy"];
            this.isDeleted = _data["isDeleted"];
            this.companyId = _data["companyId"];
            this.companyCode = _data["companyCode"];
            this.companyName = _data["companyName"];
        }
    }

    static fromJS(data: any): StoreDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["storeCode"] = this.storeCode;
        data["storeName"] = this.storeName;
        data["normalizedStoreName"] = this.normalizedStoreName;
        data["order"] = this.order;
        data["isActive"] = this.isActive;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["updatedBy"] = this.updatedBy;
        data["isDeleted"] = this.isDeleted;
        data["companyId"] = this.companyId;
        data["companyCode"] = this.companyCode;
        data["companyName"] = this.companyName;
        return data; 
    }
}

export interface IStoreDto {
    id?: number;
    storeCode?: string | undefined;
    storeName?: string | undefined;
    normalizedStoreName?: string | undefined;
    order?: number;
    isActive?: boolean;
    createdAt?: Date;
    createdBy?: string | undefined;
    updatedAt?: Date | undefined;
    updatedBy?: string | undefined;
    isDeleted?: boolean;
    companyId?: number;
    companyCode?: string | undefined;
    companyName?: string | undefined;
}

export class UpdateDeviceMobileCommand implements IUpdateDeviceMobileCommand {
    id?: number;
    lat?: string | undefined;
    long?: string | undefined;

    constructor(data?: IUpdateDeviceMobileCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.lat = _data["lat"];
            this.long = _data["long"];
        }
    }

    static fromJS(data: any): UpdateDeviceMobileCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDeviceMobileCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["lat"] = this.lat;
        data["long"] = this.long;
        return data; 
    }
}

export interface IUpdateDeviceMobileCommand {
    id?: number;
    lat?: string | undefined;
    long?: string | undefined;
}

export class PaginatedListOfKidDto implements IPaginatedListOfKidDto {
    items?: KidDto[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfKidDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(KidDto.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfKidDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfKidDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data; 
    }
}

export interface IPaginatedListOfKidDto {
    items?: KidDto[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class KidDto implements IKidDto {
    id?: number;
    createdAt?: Date;
    memberNo?: string | undefined;
    parentFirstName?: string | undefined;
    parentLastName?: string | undefined;
    parentName?: string | undefined;
    parentFuriganaFirstName?: string | undefined;
    parentFuriganaLastName?: string | undefined;
    parentFuriganaName?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    fullName?: string | undefined;
    furiganaFirstName?: string | undefined;
    furiganaLastName?: string | undefined;
    furiganaName?: string | undefined;
    sex?: number;
    dateOfBirth?: Date;
    relationshipMember?: number;
    picStoreId?: number | undefined;
    picStoreName?: string | undefined;

    constructor(data?: IKidDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.memberNo = _data["memberNo"];
            this.parentFirstName = _data["parentFirstName"];
            this.parentLastName = _data["parentLastName"];
            this.parentName = _data["parentName"];
            this.parentFuriganaFirstName = _data["parentFuriganaFirstName"];
            this.parentFuriganaLastName = _data["parentFuriganaLastName"];
            this.parentFuriganaName = _data["parentFuriganaName"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.fullName = _data["fullName"];
            this.furiganaFirstName = _data["furiganaFirstName"];
            this.furiganaLastName = _data["furiganaLastName"];
            this.furiganaName = _data["furiganaName"];
            this.sex = _data["sex"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.relationshipMember = _data["relationshipMember"];
            this.picStoreId = _data["picStoreId"];
            this.picStoreName = _data["picStoreName"];
        }
    }

    static fromJS(data: any): KidDto {
        data = typeof data === 'object' ? data : {};
        let result = new KidDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["memberNo"] = this.memberNo;
        data["parentFirstName"] = this.parentFirstName;
        data["parentLastName"] = this.parentLastName;
        data["parentName"] = this.parentName;
        data["parentFuriganaFirstName"] = this.parentFuriganaFirstName;
        data["parentFuriganaLastName"] = this.parentFuriganaLastName;
        data["parentFuriganaName"] = this.parentFuriganaName;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["fullName"] = this.fullName;
        data["furiganaFirstName"] = this.furiganaFirstName;
        data["furiganaLastName"] = this.furiganaLastName;
        data["furiganaName"] = this.furiganaName;
        data["sex"] = this.sex;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["relationshipMember"] = this.relationshipMember;
        data["picStoreId"] = this.picStoreId;
        data["picStoreName"] = this.picStoreName;
        return data; 
    }
}

export interface IKidDto {
    id?: number;
    createdAt?: Date;
    memberNo?: string | undefined;
    parentFirstName?: string | undefined;
    parentLastName?: string | undefined;
    parentName?: string | undefined;
    parentFuriganaFirstName?: string | undefined;
    parentFuriganaLastName?: string | undefined;
    parentFuriganaName?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    fullName?: string | undefined;
    furiganaFirstName?: string | undefined;
    furiganaLastName?: string | undefined;
    furiganaName?: string | undefined;
    sex?: number;
    dateOfBirth?: Date;
    relationshipMember?: number;
    picStoreId?: number | undefined;
    picStoreName?: string | undefined;
}

export class KidDetailDto implements IKidDetailDto {
    id?: number;
    memberNo?: string | undefined;
    parentFirstName?: string | undefined;
    parentLastName?: string | undefined;
    parentFuriganaFirstName?: string | undefined;
    parentFuriganaLastName?: string | undefined;
    relationshipMember?: number;
    relationshipMemberText?: string | undefined;
    email?: string | undefined;
    registerKidClubDate?: Date;
    requestType?: RequestTypeEnum;
    requestTypeText?: string | undefined;
    companyId?: string | undefined;
    companyCode?: string | undefined;
    companyName?: string | undefined;
    storeId?: number;
    storeCode?: string | undefined;
    storeName?: string | undefined;
    picStoreId?: number | undefined;
    picStoreName?: string | undefined;
    deviceCode?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    furiganaFirstName?: string | undefined;
    furiganaLastName?: string | undefined;
    sex?: number;
    sexTypeText?: string | undefined;
    isLivingWithParent?: boolean;
    isLivingWithParentText?: string | undefined;
    dateOfBirth?: Date;
    remark?: string | undefined;
    updatedAt?: Date | undefined;
    createdBy?: string | undefined;
    isEnableEdit?: boolean;

    constructor(data?: IKidDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.memberNo = _data["memberNo"];
            this.parentFirstName = _data["parentFirstName"];
            this.parentLastName = _data["parentLastName"];
            this.parentFuriganaFirstName = _data["parentFuriganaFirstName"];
            this.parentFuriganaLastName = _data["parentFuriganaLastName"];
            this.relationshipMember = _data["relationshipMember"];
            this.relationshipMemberText = _data["relationshipMemberText"];
            this.email = _data["email"];
            this.registerKidClubDate = _data["registerKidClubDate"] ? new Date(_data["registerKidClubDate"].toString()) : <any>undefined;
            this.requestType = _data["requestType"];
            this.requestTypeText = _data["requestTypeText"];
            this.companyId = _data["companyId"];
            this.companyCode = _data["companyCode"];
            this.companyName = _data["companyName"];
            this.storeId = _data["storeId"];
            this.storeCode = _data["storeCode"];
            this.storeName = _data["storeName"];
            this.picStoreId = _data["picStoreId"];
            this.picStoreName = _data["picStoreName"];
            this.deviceCode = _data["deviceCode"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.furiganaFirstName = _data["furiganaFirstName"];
            this.furiganaLastName = _data["furiganaLastName"];
            this.sex = _data["sex"];
            this.sexTypeText = _data["sexTypeText"];
            this.isLivingWithParent = _data["isLivingWithParent"];
            this.isLivingWithParentText = _data["isLivingWithParentText"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.remark = _data["remark"];
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.isEnableEdit = _data["isEnableEdit"];
        }
    }

    static fromJS(data: any): KidDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new KidDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["memberNo"] = this.memberNo;
        data["parentFirstName"] = this.parentFirstName;
        data["parentLastName"] = this.parentLastName;
        data["parentFuriganaFirstName"] = this.parentFuriganaFirstName;
        data["parentFuriganaLastName"] = this.parentFuriganaLastName;
        data["relationshipMember"] = this.relationshipMember;
        data["relationshipMemberText"] = this.relationshipMemberText;
        data["email"] = this.email;
        data["registerKidClubDate"] = this.registerKidClubDate ? this.registerKidClubDate.toISOString() : <any>undefined;
        data["requestType"] = this.requestType;
        data["requestTypeText"] = this.requestTypeText;
        data["companyId"] = this.companyId;
        data["companyCode"] = this.companyCode;
        data["companyName"] = this.companyName;
        data["storeId"] = this.storeId;
        data["storeCode"] = this.storeCode;
        data["storeName"] = this.storeName;
        data["picStoreId"] = this.picStoreId;
        data["picStoreName"] = this.picStoreName;
        data["deviceCode"] = this.deviceCode;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["furiganaFirstName"] = this.furiganaFirstName;
        data["furiganaLastName"] = this.furiganaLastName;
        data["sex"] = this.sex;
        data["sexTypeText"] = this.sexTypeText;
        data["isLivingWithParent"] = this.isLivingWithParent;
        data["isLivingWithParentText"] = this.isLivingWithParentText;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["remark"] = this.remark;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["isEnableEdit"] = this.isEnableEdit;
        return data; 
    }
}

export interface IKidDetailDto {
    id?: number;
    memberNo?: string | undefined;
    parentFirstName?: string | undefined;
    parentLastName?: string | undefined;
    parentFuriganaFirstName?: string | undefined;
    parentFuriganaLastName?: string | undefined;
    relationshipMember?: number;
    relationshipMemberText?: string | undefined;
    email?: string | undefined;
    registerKidClubDate?: Date;
    requestType?: RequestTypeEnum;
    requestTypeText?: string | undefined;
    companyId?: string | undefined;
    companyCode?: string | undefined;
    companyName?: string | undefined;
    storeId?: number;
    storeCode?: string | undefined;
    storeName?: string | undefined;
    picStoreId?: number | undefined;
    picStoreName?: string | undefined;
    deviceCode?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    furiganaFirstName?: string | undefined;
    furiganaLastName?: string | undefined;
    sex?: number;
    sexTypeText?: string | undefined;
    isLivingWithParent?: boolean;
    isLivingWithParentText?: string | undefined;
    dateOfBirth?: Date;
    remark?: string | undefined;
    updatedAt?: Date | undefined;
    createdBy?: string | undefined;
    isEnableEdit?: boolean;
}

export enum RequestTypeEnum {
    New = 1,
    Switch = 2,
    ReIssued = 3,
    ChangeCard = 4,
    LeaveGroup = 5,
    PMigrate = 6,
    Kid = 7,
}

export class UpdateKidResultDto implements IUpdateKidResultDto {
    isSuccess?: boolean;
    messageCode?: string | undefined;

    constructor(data?: IUpdateKidResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.messageCode = _data["messageCode"];
        }
    }

    static fromJS(data: any): UpdateKidResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateKidResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["messageCode"] = this.messageCode;
        return data; 
    }
}

export interface IUpdateKidResultDto {
    isSuccess?: boolean;
    messageCode?: string | undefined;
}

export class UpdateKidCommand implements IUpdateKidCommand {
    id?: number;
    memberNo?: string | undefined;
    parentFirstName?: string | undefined;
    parentLastName?: string | undefined;
    relationshipMember?: KidRelationshipEnum;
    email?: string | undefined;
    picStoreId?: number | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    furiganaFirstName?: string | undefined;
    furiganaLastName?: string | undefined;
    dateOfBirth?: Date;
    sex?: SexType;
    isLivingWithParent?: boolean;
    remark?: string | undefined;
    updatedAt?: Date | undefined;

    constructor(data?: IUpdateKidCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.memberNo = _data["memberNo"];
            this.parentFirstName = _data["parentFirstName"];
            this.parentLastName = _data["parentLastName"];
            this.relationshipMember = _data["relationshipMember"];
            this.email = _data["email"];
            this.picStoreId = _data["picStoreId"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.furiganaFirstName = _data["furiganaFirstName"];
            this.furiganaLastName = _data["furiganaLastName"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.sex = _data["sex"];
            this.isLivingWithParent = _data["isLivingWithParent"];
            this.remark = _data["remark"];
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateKidCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateKidCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["memberNo"] = this.memberNo;
        data["parentFirstName"] = this.parentFirstName;
        data["parentLastName"] = this.parentLastName;
        data["relationshipMember"] = this.relationshipMember;
        data["email"] = this.email;
        data["picStoreId"] = this.picStoreId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["furiganaFirstName"] = this.furiganaFirstName;
        data["furiganaLastName"] = this.furiganaLastName;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["sex"] = this.sex;
        data["isLivingWithParent"] = this.isLivingWithParent;
        data["remark"] = this.remark;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IUpdateKidCommand {
    id?: number;
    memberNo?: string | undefined;
    parentFirstName?: string | undefined;
    parentLastName?: string | undefined;
    relationshipMember?: KidRelationshipEnum;
    email?: string | undefined;
    picStoreId?: number | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    furiganaFirstName?: string | undefined;
    furiganaLastName?: string | undefined;
    dateOfBirth?: Date;
    sex?: SexType;
    isLivingWithParent?: boolean;
    remark?: string | undefined;
    updatedAt?: Date | undefined;
}

export enum KidRelationshipEnum {
    Unset = 0,
    Father = 1,
    Mother = 2,
    GrandFarther = 3,
    GrandMother = 4,
    Other = 5,
}

export class PaginatedListOfMemberKidDeleteDto implements IPaginatedListOfMemberKidDeleteDto {
    items?: MemberKidDeleteDto[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfMemberKidDeleteDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MemberKidDeleteDto.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfMemberKidDeleteDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfMemberKidDeleteDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data; 
    }
}

export interface IPaginatedListOfMemberKidDeleteDto {
    items?: MemberKidDeleteDto[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class MemberKidDeleteDto implements IMemberKidDeleteDto {
    id?: number;
    no?: number;
    createdAt?: Date;
    memberNo?: string | undefined;
    parentName?: string | undefined;
    kidName?: string | undefined;
    sex?: number;
    dateOfBirth?: Date;
    updatedAt?: Date | undefined;
    relationshipMember?: number;
    storeId?: number | undefined;
    companyId?: number | undefined;
    store?: Store | undefined;
    company?: Company | undefined;

    constructor(data?: IMemberKidDeleteDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.no = _data["no"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.memberNo = _data["memberNo"];
            this.parentName = _data["parentName"];
            this.kidName = _data["kidName"];
            this.sex = _data["sex"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.relationshipMember = _data["relationshipMember"];
            this.storeId = _data["storeId"];
            this.companyId = _data["companyId"];
            this.store = _data["store"] ? Store.fromJS(_data["store"]) : <any>undefined;
            this.company = _data["company"] ? Company.fromJS(_data["company"]) : <any>undefined;
        }
    }

    static fromJS(data: any): MemberKidDeleteDto {
        data = typeof data === 'object' ? data : {};
        let result = new MemberKidDeleteDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["no"] = this.no;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["memberNo"] = this.memberNo;
        data["parentName"] = this.parentName;
        data["kidName"] = this.kidName;
        data["sex"] = this.sex;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["relationshipMember"] = this.relationshipMember;
        data["storeId"] = this.storeId;
        data["companyId"] = this.companyId;
        data["store"] = this.store ? this.store.toJSON() : <any>undefined;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IMemberKidDeleteDto {
    id?: number;
    no?: number;
    createdAt?: Date;
    memberNo?: string | undefined;
    parentName?: string | undefined;
    kidName?: string | undefined;
    sex?: number;
    dateOfBirth?: Date;
    updatedAt?: Date | undefined;
    relationshipMember?: number;
    storeId?: number | undefined;
    companyId?: number | undefined;
    store?: Store | undefined;
    company?: Company | undefined;
}

export class DeleteKidsCommand implements IDeleteKidsCommand {
    kidsDelete?: MemberKidDeleteCommandDto[] | undefined;

    constructor(data?: IDeleteKidsCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["kidsDelete"])) {
                this.kidsDelete = [] as any;
                for (let item of _data["kidsDelete"])
                    this.kidsDelete!.push(MemberKidDeleteCommandDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DeleteKidsCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteKidsCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.kidsDelete)) {
            data["kidsDelete"] = [];
            for (let item of this.kidsDelete)
                data["kidsDelete"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IDeleteKidsCommand {
    kidsDelete?: MemberKidDeleteCommandDto[] | undefined;
}

export class MemberKidDeleteCommandDto implements IMemberKidDeleteCommandDto {
    id?: number;
    updatedAt?: Date | undefined;

    constructor(data?: IMemberKidDeleteCommandDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): MemberKidDeleteCommandDto {
        data = typeof data === 'object' ? data : {};
        let result = new MemberKidDeleteCommandDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IMemberKidDeleteCommandDto {
    id?: number;
    updatedAt?: Date | undefined;
}

export class LoginResponse implements ILoginResponse {
    user?: ApplicationUserDto | undefined;
    token?: string | undefined;

    constructor(data?: ILoginResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.user = _data["user"] ? ApplicationUserDto.fromJS(_data["user"]) : <any>undefined;
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): LoginResponse {
        data = typeof data === 'object' ? data : {};
        let result = new LoginResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["token"] = this.token;
        return data; 
    }
}

export interface ILoginResponse {
    user?: ApplicationUserDto | undefined;
    token?: string | undefined;
}

export class GetTokenQuery implements IGetTokenQuery {
    email?: string | undefined;
    password?: string | undefined;
    isWebApp?: boolean;
    deviceId?: number | undefined;

    constructor(data?: IGetTokenQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
            this.isWebApp = _data["isWebApp"];
            this.deviceId = _data["deviceId"];
        }
    }

    static fromJS(data: any): GetTokenQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetTokenQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        data["isWebApp"] = this.isWebApp;
        data["deviceId"] = this.deviceId;
        return data; 
    }
}

export interface IGetTokenQuery {
    email?: string | undefined;
    password?: string | undefined;
    isWebApp?: boolean;
    deviceId?: number | undefined;
}

export class RegisterMemberCommand implements IRegisterMemberCommand {
    memberNo?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    furiganaFirstName?: string | undefined;
    furiganaLastName?: string | undefined;
    sex?: SexType;
    zipcodeId?: string | undefined;
    province?: string | undefined;
    district?: string | undefined;
    street?: string | undefined;
    isRegisterAdvertisement?: boolean;
    dateOfBirth?: Date;
    fixedPhone?: string | undefined;
    mobilePhone?: string | undefined;
    email?: string | undefined;
    remark?: string | undefined;
    buildingName?: string | undefined;
    memberKids?: MemberKidDto[] | undefined;
    storeId?: number;
    deviceId?: number;
    gmt?: number;

    constructor(data?: IRegisterMemberCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberNo = _data["memberNo"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.furiganaFirstName = _data["furiganaFirstName"];
            this.furiganaLastName = _data["furiganaLastName"];
            this.sex = _data["sex"];
            this.zipcodeId = _data["zipcodeId"];
            this.province = _data["province"];
            this.district = _data["district"];
            this.street = _data["street"];
            this.isRegisterAdvertisement = _data["isRegisterAdvertisement"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.fixedPhone = _data["fixedPhone"];
            this.mobilePhone = _data["mobilePhone"];
            this.email = _data["email"];
            this.remark = _data["remark"];
            this.buildingName = _data["buildingName"];
            if (Array.isArray(_data["memberKids"])) {
                this.memberKids = [] as any;
                for (let item of _data["memberKids"])
                    this.memberKids!.push(MemberKidDto.fromJS(item));
            }
            this.storeId = _data["storeId"];
            this.deviceId = _data["deviceId"];
            this.gmt = _data["gmt"];
        }
    }

    static fromJS(data: any): RegisterMemberCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterMemberCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberNo"] = this.memberNo;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["furiganaFirstName"] = this.furiganaFirstName;
        data["furiganaLastName"] = this.furiganaLastName;
        data["sex"] = this.sex;
        data["zipcodeId"] = this.zipcodeId;
        data["province"] = this.province;
        data["district"] = this.district;
        data["street"] = this.street;
        data["isRegisterAdvertisement"] = this.isRegisterAdvertisement;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["fixedPhone"] = this.fixedPhone;
        data["mobilePhone"] = this.mobilePhone;
        data["email"] = this.email;
        data["remark"] = this.remark;
        data["buildingName"] = this.buildingName;
        if (Array.isArray(this.memberKids)) {
            data["memberKids"] = [];
            for (let item of this.memberKids)
                data["memberKids"].push(item.toJSON());
        }
        data["storeId"] = this.storeId;
        data["deviceId"] = this.deviceId;
        data["gmt"] = this.gmt;
        return data; 
    }
}

export interface IRegisterMemberCommand {
    memberNo?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    furiganaFirstName?: string | undefined;
    furiganaLastName?: string | undefined;
    sex?: SexType;
    zipcodeId?: string | undefined;
    province?: string | undefined;
    district?: string | undefined;
    street?: string | undefined;
    isRegisterAdvertisement?: boolean;
    dateOfBirth?: Date;
    fixedPhone?: string | undefined;
    mobilePhone?: string | undefined;
    email?: string | undefined;
    remark?: string | undefined;
    buildingName?: string | undefined;
    memberKids?: MemberKidDto[] | undefined;
    storeId?: number;
    deviceId?: number;
    gmt?: number;
}

export class MemberKidDto implements IMemberKidDto {
    parentFirstName?: string | undefined;
    parentLastName?: string | undefined;
    parentFuriganaFirstName?: string | undefined;
    parentFuriganaLastName?: string | undefined;
    relationshipMember?: number;
    firstName?: string | undefined;
    lastName?: string | undefined;
    furiganaFirstName?: string | undefined;
    furiganaLastName?: string | undefined;
    sex?: SexType;
    isLivingWithParent?: boolean;
    dateOfBirth?: Date;

    constructor(data?: IMemberKidDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentFirstName = _data["parentFirstName"];
            this.parentLastName = _data["parentLastName"];
            this.parentFuriganaFirstName = _data["parentFuriganaFirstName"];
            this.parentFuriganaLastName = _data["parentFuriganaLastName"];
            this.relationshipMember = _data["relationshipMember"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.furiganaFirstName = _data["furiganaFirstName"];
            this.furiganaLastName = _data["furiganaLastName"];
            this.sex = _data["sex"];
            this.isLivingWithParent = _data["isLivingWithParent"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): MemberKidDto {
        data = typeof data === 'object' ? data : {};
        let result = new MemberKidDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentFirstName"] = this.parentFirstName;
        data["parentLastName"] = this.parentLastName;
        data["parentFuriganaFirstName"] = this.parentFuriganaFirstName;
        data["parentFuriganaLastName"] = this.parentFuriganaLastName;
        data["relationshipMember"] = this.relationshipMember;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["furiganaFirstName"] = this.furiganaFirstName;
        data["furiganaLastName"] = this.furiganaLastName;
        data["sex"] = this.sex;
        data["isLivingWithParent"] = this.isLivingWithParent;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IMemberKidDto {
    parentFirstName?: string | undefined;
    parentLastName?: string | undefined;
    parentFuriganaFirstName?: string | undefined;
    parentFuriganaLastName?: string | undefined;
    relationshipMember?: number;
    firstName?: string | undefined;
    lastName?: string | undefined;
    furiganaFirstName?: string | undefined;
    furiganaLastName?: string | undefined;
    sex?: SexType;
    isLivingWithParent?: boolean;
    dateOfBirth?: Date;
}

export class MemberInfoDto implements IMemberInfoDto {
    id?: number;
    firstName?: string | undefined;
    lastName?: string | undefined;
    furiganaFirstName?: string | undefined;
    furiganaLastName?: string | undefined;
    sex?: number;
    zipcode?: string | undefined;
    province?: string | undefined;
    city?: string | undefined;
    address?: string | undefined;
    buildingName?: string | undefined;
    isRegisterAdvertisement?: boolean;
    isUpdateInformation?: boolean;
    isNetMember?: boolean;
    dateOfBirth?: Date | undefined;
    fixedPhone?: string | undefined;
    mobilePhone?: string | undefined;
    email?: string | undefined;
    remark?: string | undefined;
    memberNo?: string | undefined;
    oldMemberNo?: string | undefined;

    constructor(data?: IMemberInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.furiganaFirstName = _data["furiganaFirstName"];
            this.furiganaLastName = _data["furiganaLastName"];
            this.sex = _data["sex"];
            this.zipcode = _data["zipcode"];
            this.province = _data["province"];
            this.city = _data["city"];
            this.address = _data["address"];
            this.buildingName = _data["buildingName"];
            this.isRegisterAdvertisement = _data["isRegisterAdvertisement"];
            this.isUpdateInformation = _data["isUpdateInformation"];
            this.isNetMember = _data["isNetMember"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.fixedPhone = _data["fixedPhone"];
            this.mobilePhone = _data["mobilePhone"];
            this.email = _data["email"];
            this.remark = _data["remark"];
            this.memberNo = _data["memberNo"];
            this.oldMemberNo = _data["oldMemberNo"];
        }
    }

    static fromJS(data: any): MemberInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new MemberInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["furiganaFirstName"] = this.furiganaFirstName;
        data["furiganaLastName"] = this.furiganaLastName;
        data["sex"] = this.sex;
        data["zipcode"] = this.zipcode;
        data["province"] = this.province;
        data["city"] = this.city;
        data["address"] = this.address;
        data["buildingName"] = this.buildingName;
        data["isRegisterAdvertisement"] = this.isRegisterAdvertisement;
        data["isUpdateInformation"] = this.isUpdateInformation;
        data["isNetMember"] = this.isNetMember;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["fixedPhone"] = this.fixedPhone;
        data["mobilePhone"] = this.mobilePhone;
        data["email"] = this.email;
        data["remark"] = this.remark;
        data["memberNo"] = this.memberNo;
        data["oldMemberNo"] = this.oldMemberNo;
        return data; 
    }
}

export interface IMemberInfoDto {
    id?: number;
    firstName?: string | undefined;
    lastName?: string | undefined;
    furiganaFirstName?: string | undefined;
    furiganaLastName?: string | undefined;
    sex?: number;
    zipcode?: string | undefined;
    province?: string | undefined;
    city?: string | undefined;
    address?: string | undefined;
    buildingName?: string | undefined;
    isRegisterAdvertisement?: boolean;
    isUpdateInformation?: boolean;
    isNetMember?: boolean;
    dateOfBirth?: Date | undefined;
    fixedPhone?: string | undefined;
    mobilePhone?: string | undefined;
    email?: string | undefined;
    remark?: string | undefined;
    memberNo?: string | undefined;
    oldMemberNo?: string | undefined;
}

export class CardValidationDto implements ICardValidationDto {
    isValidated?: boolean;
    message?: string | undefined;

    constructor(data?: ICardValidationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isValidated = _data["isValidated"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): CardValidationDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardValidationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isValidated"] = this.isValidated;
        data["message"] = this.message;
        return data; 
    }
}

export interface ICardValidationDto {
    isValidated?: boolean;
    message?: string | undefined;
}

export class ZipcodeDto implements IZipcodeDto {
    zipcode?: string | undefined;
    province?: string | undefined;
    district?: string | undefined;
    street?: string | undefined;

    constructor(data?: IZipcodeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.zipcode = _data["zipcode"];
            this.province = _data["province"];
            this.district = _data["district"];
            this.street = _data["street"];
        }
    }

    static fromJS(data: any): ZipcodeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ZipcodeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["zipcode"] = this.zipcode;
        data["province"] = this.province;
        data["district"] = this.district;
        data["street"] = this.street;
        return data; 
    }
}

export interface IZipcodeDto {
    zipcode?: string | undefined;
    province?: string | undefined;
    district?: string | undefined;
    street?: string | undefined;
}

export class UpdateMemberCommand implements IUpdateMemberCommand {
    memberObject?: UpdateMemberNoCommand | undefined;
    member?: MemberCommand | undefined;
    updateType?: RequestTypeEnum;
    requestTypeDetail?: RequestTypeDetail;
    storeId?: number;
    gmt?: number;

    constructor(data?: IUpdateMemberCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberObject = _data["memberObject"] ? UpdateMemberNoCommand.fromJS(_data["memberObject"]) : <any>undefined;
            this.member = _data["member"] ? MemberCommand.fromJS(_data["member"]) : <any>undefined;
            this.updateType = _data["updateType"];
            this.requestTypeDetail = _data["requestTypeDetail"];
            this.storeId = _data["storeId"];
            this.gmt = _data["gmt"];
        }
    }

    static fromJS(data: any): UpdateMemberCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateMemberCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberObject"] = this.memberObject ? this.memberObject.toJSON() : <any>undefined;
        data["member"] = this.member ? this.member.toJSON() : <any>undefined;
        data["updateType"] = this.updateType;
        data["requestTypeDetail"] = this.requestTypeDetail;
        data["storeId"] = this.storeId;
        data["gmt"] = this.gmt;
        return data; 
    }
}

export interface IUpdateMemberCommand {
    memberObject?: UpdateMemberNoCommand | undefined;
    member?: MemberCommand | undefined;
    updateType?: RequestTypeEnum;
    requestTypeDetail?: RequestTypeDetail;
    storeId?: number;
    gmt?: number;
}

export class UpdateMemberNoCommand implements IUpdateMemberNoCommand {
    oldMemberNo?: string | undefined;
    newMemberNo?: string | undefined;
    deviceId?: number;
    isUpdateInformation?: boolean;
    updateType?: RequestTypeEnum;
    requestTypeDetail?: RequestTypeDetail;
    storeId?: number;
    gmt?: number;

    constructor(data?: IUpdateMemberNoCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.oldMemberNo = _data["oldMemberNo"];
            this.newMemberNo = _data["newMemberNo"];
            this.deviceId = _data["deviceId"];
            this.isUpdateInformation = _data["isUpdateInformation"];
            this.updateType = _data["updateType"];
            this.requestTypeDetail = _data["requestTypeDetail"];
            this.storeId = _data["storeId"];
            this.gmt = _data["gmt"];
        }
    }

    static fromJS(data: any): UpdateMemberNoCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateMemberNoCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["oldMemberNo"] = this.oldMemberNo;
        data["newMemberNo"] = this.newMemberNo;
        data["deviceId"] = this.deviceId;
        data["isUpdateInformation"] = this.isUpdateInformation;
        data["updateType"] = this.updateType;
        data["requestTypeDetail"] = this.requestTypeDetail;
        data["storeId"] = this.storeId;
        data["gmt"] = this.gmt;
        return data; 
    }
}

export interface IUpdateMemberNoCommand {
    oldMemberNo?: string | undefined;
    newMemberNo?: string | undefined;
    deviceId?: number;
    isUpdateInformation?: boolean;
    updateType?: RequestTypeEnum;
    requestTypeDetail?: RequestTypeDetail;
    storeId?: number;
    gmt?: number;
}

export class MemberCommand implements IMemberCommand {
    memberNo?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    furiganaFirstName?: string | undefined;
    furiganaLastName?: string | undefined;
    sex?: SexType;
    zipcodeId?: string | undefined;
    province?: string | undefined;
    district?: string | undefined;
    street?: string | undefined;
    buildingName?: string | undefined;
    isRegisterAdvertisement?: boolean;
    dateOfBirth?: Date;
    fixedPhone?: string | undefined;
    mobilePhone?: string | undefined;
    email?: string | undefined;
    remark?: string | undefined;
    deviceId?: number;
    isUpdateInformation?: boolean;
    memberKids?: MemberKidDto2[] | undefined;

    constructor(data?: IMemberCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberNo = _data["memberNo"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.furiganaFirstName = _data["furiganaFirstName"];
            this.furiganaLastName = _data["furiganaLastName"];
            this.sex = _data["sex"];
            this.zipcodeId = _data["zipcodeId"];
            this.province = _data["province"];
            this.district = _data["district"];
            this.street = _data["street"];
            this.buildingName = _data["buildingName"];
            this.isRegisterAdvertisement = _data["isRegisterAdvertisement"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.fixedPhone = _data["fixedPhone"];
            this.mobilePhone = _data["mobilePhone"];
            this.email = _data["email"];
            this.remark = _data["remark"];
            this.deviceId = _data["deviceId"];
            this.isUpdateInformation = _data["isUpdateInformation"];
            if (Array.isArray(_data["memberKids"])) {
                this.memberKids = [] as any;
                for (let item of _data["memberKids"])
                    this.memberKids!.push(MemberKidDto2.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MemberCommand {
        data = typeof data === 'object' ? data : {};
        let result = new MemberCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberNo"] = this.memberNo;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["furiganaFirstName"] = this.furiganaFirstName;
        data["furiganaLastName"] = this.furiganaLastName;
        data["sex"] = this.sex;
        data["zipcodeId"] = this.zipcodeId;
        data["province"] = this.province;
        data["district"] = this.district;
        data["street"] = this.street;
        data["buildingName"] = this.buildingName;
        data["isRegisterAdvertisement"] = this.isRegisterAdvertisement;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["fixedPhone"] = this.fixedPhone;
        data["mobilePhone"] = this.mobilePhone;
        data["email"] = this.email;
        data["remark"] = this.remark;
        data["deviceId"] = this.deviceId;
        data["isUpdateInformation"] = this.isUpdateInformation;
        if (Array.isArray(this.memberKids)) {
            data["memberKids"] = [];
            for (let item of this.memberKids)
                data["memberKids"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IMemberCommand {
    memberNo?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    furiganaFirstName?: string | undefined;
    furiganaLastName?: string | undefined;
    sex?: SexType;
    zipcodeId?: string | undefined;
    province?: string | undefined;
    district?: string | undefined;
    street?: string | undefined;
    buildingName?: string | undefined;
    isRegisterAdvertisement?: boolean;
    dateOfBirth?: Date;
    fixedPhone?: string | undefined;
    mobilePhone?: string | undefined;
    email?: string | undefined;
    remark?: string | undefined;
    deviceId?: number;
    isUpdateInformation?: boolean;
    memberKids?: MemberKidDto2[] | undefined;
}

export class MemberKidDto2 implements IMemberKidDto2 {
    parentFirstName?: string | undefined;
    parentLastName?: string | undefined;
    parentFuriganaFirstName?: string | undefined;
    parentFuriganaLastName?: string | undefined;
    relaionshipMember?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    furiganaFirstName?: string | undefined;
    furiganaLastName?: string | undefined;
    sex?: SexType;
    isLivingWithParent?: boolean;
    dateOfBirth?: Date;

    constructor(data?: IMemberKidDto2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentFirstName = _data["parentFirstName"];
            this.parentLastName = _data["parentLastName"];
            this.parentFuriganaFirstName = _data["parentFuriganaFirstName"];
            this.parentFuriganaLastName = _data["parentFuriganaLastName"];
            this.relaionshipMember = _data["relaionshipMember"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.furiganaFirstName = _data["furiganaFirstName"];
            this.furiganaLastName = _data["furiganaLastName"];
            this.sex = _data["sex"];
            this.isLivingWithParent = _data["isLivingWithParent"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): MemberKidDto2 {
        data = typeof data === 'object' ? data : {};
        let result = new MemberKidDto2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentFirstName"] = this.parentFirstName;
        data["parentLastName"] = this.parentLastName;
        data["parentFuriganaFirstName"] = this.parentFuriganaFirstName;
        data["parentFuriganaLastName"] = this.parentFuriganaLastName;
        data["relaionshipMember"] = this.relaionshipMember;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["furiganaFirstName"] = this.furiganaFirstName;
        data["furiganaLastName"] = this.furiganaLastName;
        data["sex"] = this.sex;
        data["isLivingWithParent"] = this.isLivingWithParent;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IMemberKidDto2 {
    parentFirstName?: string | undefined;
    parentLastName?: string | undefined;
    parentFuriganaFirstName?: string | undefined;
    parentFuriganaLastName?: string | undefined;
    relaionshipMember?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    furiganaFirstName?: string | undefined;
    furiganaLastName?: string | undefined;
    sex?: SexType;
    isLivingWithParent?: boolean;
    dateOfBirth?: Date;
}

export class UpdateRemarkPICQuery implements IUpdateRemarkPICQuery {
    requestId?: number;
    picStoreId?: number;
    remark?: string | undefined;

    constructor(data?: IUpdateRemarkPICQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.requestId = _data["requestId"];
            this.picStoreId = _data["picStoreId"];
            this.remark = _data["remark"];
        }
    }

    static fromJS(data: any): UpdateRemarkPICQuery {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRemarkPICQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requestId"] = this.requestId;
        data["picStoreId"] = this.picStoreId;
        data["remark"] = this.remark;
        return data; 
    }
}

export interface IUpdateRemarkPICQuery {
    requestId?: number;
    picStoreId?: number;
    remark?: string | undefined;
}

export class PersonInchargeDto implements IPersonInchargeDto {
    id?: number;
    picCode?: string | undefined;
    picName?: string | undefined;

    constructor(data?: IPersonInchargeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.picCode = _data["picCode"];
            this.picName = _data["picName"];
        }
    }

    static fromJS(data: any): PersonInchargeDto {
        data = typeof data === 'object' ? data : {};
        let result = new PersonInchargeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["picCode"] = this.picCode;
        data["picName"] = this.picName;
        return data; 
    }
}

export interface IPersonInchargeDto {
    id?: number;
    picCode?: string | undefined;
    picName?: string | undefined;
}

export class GetListPersonInchargeQuery implements IGetListPersonInchargeQuery {
    storeId?: number;

    constructor(data?: IGetListPersonInchargeQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeId = _data["storeId"];
        }
    }

    static fromJS(data: any): GetListPersonInchargeQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetListPersonInchargeQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeId"] = this.storeId;
        return data; 
    }
}

export interface IGetListPersonInchargeQuery {
    storeId?: number;
}

export class LeaveGroupRequestCommand implements ILeaveGroupRequestCommand {
    memberNo?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    furiganaFirstName?: string | undefined;
    furiganaLastName?: string | undefined;
    dateOfBirth?: Date;
    mobilePhone?: string | undefined;
    storeId?: number;
    deviceId?: number;
    gmt?: number;

    constructor(data?: ILeaveGroupRequestCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberNo = _data["memberNo"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.furiganaFirstName = _data["furiganaFirstName"];
            this.furiganaLastName = _data["furiganaLastName"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.mobilePhone = _data["mobilePhone"];
            this.storeId = _data["storeId"];
            this.deviceId = _data["deviceId"];
            this.gmt = _data["gmt"];
        }
    }

    static fromJS(data: any): LeaveGroupRequestCommand {
        data = typeof data === 'object' ? data : {};
        let result = new LeaveGroupRequestCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberNo"] = this.memberNo;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["furiganaFirstName"] = this.furiganaFirstName;
        data["furiganaLastName"] = this.furiganaLastName;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["mobilePhone"] = this.mobilePhone;
        data["storeId"] = this.storeId;
        data["deviceId"] = this.deviceId;
        data["gmt"] = this.gmt;
        return data; 
    }
}

export interface ILeaveGroupRequestCommand {
    memberNo?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    furiganaFirstName?: string | undefined;
    furiganaLastName?: string | undefined;
    dateOfBirth?: Date;
    mobilePhone?: string | undefined;
    storeId?: number;
    deviceId?: number;
    gmt?: number;
}

export class RegisterKidsClubCommand implements IRegisterKidsClubCommand {
    memberNo?: string | undefined;
    email?: string | undefined;
    storeId?: number;
    deviceId?: number;
    memberKids?: RegisterKidDto[] | undefined;
    gmt?: number;

    constructor(data?: IRegisterKidsClubCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberNo = _data["memberNo"];
            this.email = _data["email"];
            this.storeId = _data["storeId"];
            this.deviceId = _data["deviceId"];
            if (Array.isArray(_data["memberKids"])) {
                this.memberKids = [] as any;
                for (let item of _data["memberKids"])
                    this.memberKids!.push(RegisterKidDto.fromJS(item));
            }
            this.gmt = _data["gmt"];
        }
    }

    static fromJS(data: any): RegisterKidsClubCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterKidsClubCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberNo"] = this.memberNo;
        data["email"] = this.email;
        data["storeId"] = this.storeId;
        data["deviceId"] = this.deviceId;
        if (Array.isArray(this.memberKids)) {
            data["memberKids"] = [];
            for (let item of this.memberKids)
                data["memberKids"].push(item.toJSON());
        }
        data["gmt"] = this.gmt;
        return data; 
    }
}

export interface IRegisterKidsClubCommand {
    memberNo?: string | undefined;
    email?: string | undefined;
    storeId?: number;
    deviceId?: number;
    memberKids?: RegisterKidDto[] | undefined;
    gmt?: number;
}

export class RegisterKidDto implements IRegisterKidDto {
    parentFirstName?: string | undefined;
    parentLastName?: string | undefined;
    parentFuriganaFirstName?: string | undefined;
    parentFuriganaLastName?: string | undefined;
    relationshipMember?: number;
    firstName?: string | undefined;
    lastName?: string | undefined;
    furiganaFirstName?: string | undefined;
    furiganaLastName?: string | undefined;
    sex?: SexType;
    isLivingWithParent?: boolean;
    dateOfBirth?: Date;

    constructor(data?: IRegisterKidDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentFirstName = _data["parentFirstName"];
            this.parentLastName = _data["parentLastName"];
            this.parentFuriganaFirstName = _data["parentFuriganaFirstName"];
            this.parentFuriganaLastName = _data["parentFuriganaLastName"];
            this.relationshipMember = _data["relationshipMember"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.furiganaFirstName = _data["furiganaFirstName"];
            this.furiganaLastName = _data["furiganaLastName"];
            this.sex = _data["sex"];
            this.isLivingWithParent = _data["isLivingWithParent"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): RegisterKidDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterKidDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentFirstName"] = this.parentFirstName;
        data["parentLastName"] = this.parentLastName;
        data["parentFuriganaFirstName"] = this.parentFuriganaFirstName;
        data["parentFuriganaLastName"] = this.parentFuriganaLastName;
        data["relationshipMember"] = this.relationshipMember;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["furiganaFirstName"] = this.furiganaFirstName;
        data["furiganaLastName"] = this.furiganaLastName;
        data["sex"] = this.sex;
        data["isLivingWithParent"] = this.isLivingWithParent;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IRegisterKidDto {
    parentFirstName?: string | undefined;
    parentLastName?: string | undefined;
    parentFuriganaFirstName?: string | undefined;
    parentFuriganaLastName?: string | undefined;
    relationshipMember?: number;
    firstName?: string | undefined;
    lastName?: string | undefined;
    furiganaFirstName?: string | undefined;
    furiganaLastName?: string | undefined;
    sex?: SexType;
    isLivingWithParent?: boolean;
    dateOfBirth?: Date;
}

export class PaginatedListOfInquiryKidClubDto implements IPaginatedListOfInquiryKidClubDto {
    items?: InquiryKidClubDto[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfInquiryKidClubDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(InquiryKidClubDto.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfInquiryKidClubDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfInquiryKidClubDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data; 
    }
}

export interface IPaginatedListOfInquiryKidClubDto {
    items?: InquiryKidClubDto[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class InquiryKidClubDto implements IInquiryKidClubDto {
    id?: number;
    no?: number;
    memberNo?: string | undefined;
    receiptedDatetime?: Date | undefined;
    guardianName?: string | undefined;
    kidName?: string | undefined;
    picName?: string | undefined;
    remark?: string | undefined;

    constructor(data?: IInquiryKidClubDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.no = _data["no"];
            this.memberNo = _data["memberNo"];
            this.receiptedDatetime = _data["receiptedDatetime"] ? new Date(_data["receiptedDatetime"].toString()) : <any>undefined;
            this.guardianName = _data["guardianName"];
            this.kidName = _data["kidName"];
            this.picName = _data["picName"];
            this.remark = _data["remark"];
        }
    }

    static fromJS(data: any): InquiryKidClubDto {
        data = typeof data === 'object' ? data : {};
        let result = new InquiryKidClubDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["no"] = this.no;
        data["memberNo"] = this.memberNo;
        data["receiptedDatetime"] = this.receiptedDatetime ? this.receiptedDatetime.toISOString() : <any>undefined;
        data["guardianName"] = this.guardianName;
        data["kidName"] = this.kidName;
        data["picName"] = this.picName;
        data["remark"] = this.remark;
        return data; 
    }
}

export interface IInquiryKidClubDto {
    id?: number;
    no?: number;
    memberNo?: string | undefined;
    receiptedDatetime?: Date | undefined;
    guardianName?: string | undefined;
    kidName?: string | undefined;
    picName?: string | undefined;
    remark?: string | undefined;
}

export class InquiryKidClubDetailDto implements IInquiryKidClubDetailDto {
    id?: number;
    receiptedDatetime?: Date | undefined;
    relationshipMember?: number;
    guardianFirstName?: string | undefined;
    guardianLastName?: string | undefined;
    guardianFuriganaFirstName?: string | undefined;
    guardianFuriganaLastName?: string | undefined;
    isLivingWithParent?: boolean;
    firstName?: string | undefined;
    lastName?: string | undefined;
    furiganaFirstName?: string | undefined;
    furiganaLastName?: string | undefined;
    dateOfBirth?: Date | undefined;
    remarks?: string | undefined;
    kidGender?: string | undefined;

    constructor(data?: IInquiryKidClubDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.receiptedDatetime = _data["receiptedDatetime"] ? new Date(_data["receiptedDatetime"].toString()) : <any>undefined;
            this.relationshipMember = _data["relationshipMember"];
            this.guardianFirstName = _data["guardianFirstName"];
            this.guardianLastName = _data["guardianLastName"];
            this.guardianFuriganaFirstName = _data["guardianFuriganaFirstName"];
            this.guardianFuriganaLastName = _data["guardianFuriganaLastName"];
            this.isLivingWithParent = _data["isLivingWithParent"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.furiganaFirstName = _data["furiganaFirstName"];
            this.furiganaLastName = _data["furiganaLastName"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : <any>undefined;
            this.remarks = _data["remarks"];
            this.kidGender = _data["kidGender"];
        }
    }

    static fromJS(data: any): InquiryKidClubDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new InquiryKidClubDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["receiptedDatetime"] = this.receiptedDatetime ? this.receiptedDatetime.toISOString() : <any>undefined;
        data["relationshipMember"] = this.relationshipMember;
        data["guardianFirstName"] = this.guardianFirstName;
        data["guardianLastName"] = this.guardianLastName;
        data["guardianFuriganaFirstName"] = this.guardianFuriganaFirstName;
        data["guardianFuriganaLastName"] = this.guardianFuriganaLastName;
        data["isLivingWithParent"] = this.isLivingWithParent;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["furiganaFirstName"] = this.furiganaFirstName;
        data["furiganaLastName"] = this.furiganaLastName;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["remarks"] = this.remarks;
        data["kidGender"] = this.kidGender;
        return data; 
    }
}

export interface IInquiryKidClubDetailDto {
    id?: number;
    receiptedDatetime?: Date | undefined;
    relationshipMember?: number;
    guardianFirstName?: string | undefined;
    guardianLastName?: string | undefined;
    guardianFuriganaFirstName?: string | undefined;
    guardianFuriganaLastName?: string | undefined;
    isLivingWithParent?: boolean;
    firstName?: string | undefined;
    lastName?: string | undefined;
    furiganaFirstName?: string | undefined;
    furiganaLastName?: string | undefined;
    dateOfBirth?: Date | undefined;
    remarks?: string | undefined;
    kidGender?: string | undefined;
}

export class PaginatedListOfPICStoreDto implements IPaginatedListOfPICStoreDto {
    items?: PICStoreDto[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfPICStoreDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PICStoreDto.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfPICStoreDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfPICStoreDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data; 
    }
}

export interface IPaginatedListOfPICStoreDto {
    items?: PICStoreDto[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class CreatePICStoreCommand implements ICreatePICStoreCommand {
    picCode?: string | undefined;
    picName?: string | undefined;

    constructor(data?: ICreatePICStoreCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.picCode = _data["picCode"];
            this.picName = _data["picName"];
        }
    }

    static fromJS(data: any): CreatePICStoreCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePICStoreCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["picCode"] = this.picCode;
        data["picName"] = this.picName;
        return data; 
    }
}

export interface ICreatePICStoreCommand {
    picCode?: string | undefined;
    picName?: string | undefined;
}

export class UpdatePICStoreCommand implements IUpdatePICStoreCommand {
    id?: number;
    picCode?: string | undefined;
    picName?: string | undefined;

    constructor(data?: IUpdatePICStoreCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.picCode = _data["picCode"];
            this.picName = _data["picName"];
        }
    }

    static fromJS(data: any): UpdatePICStoreCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePICStoreCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["picCode"] = this.picCode;
        data["picName"] = this.picName;
        return data; 
    }
}

export interface IUpdatePICStoreCommand {
    id?: number;
    picCode?: string | undefined;
    picName?: string | undefined;
}

export class ReceptionGraphResult implements IReceptionGraphResult {
    total?: GraphObject | undefined;
    listData?: ReceptionGraphDto[] | undefined;

    constructor(data?: IReceptionGraphResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.total = _data["total"] ? GraphObject.fromJS(_data["total"]) : <any>undefined;
            if (Array.isArray(_data["listData"])) {
                this.listData = [] as any;
                for (let item of _data["listData"])
                    this.listData!.push(ReceptionGraphDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReceptionGraphResult {
        data = typeof data === 'object' ? data : {};
        let result = new ReceptionGraphResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total ? this.total.toJSON() : <any>undefined;
        if (Array.isArray(this.listData)) {
            data["listData"] = [];
            for (let item of this.listData)
                data["listData"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IReceptionGraphResult {
    total?: GraphObject | undefined;
    listData?: ReceptionGraphDto[] | undefined;
}

export class GraphObject implements IGraphObject {
    totalCreateCards?: number;
    totalSwitchCards?: number;
    totalKidClubs?: number;
    totalOther?: number;

    constructor(data?: IGraphObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCreateCards = _data["totalCreateCards"];
            this.totalSwitchCards = _data["totalSwitchCards"];
            this.totalKidClubs = _data["totalKidClubs"];
            this.totalOther = _data["totalOther"];
        }
    }

    static fromJS(data: any): GraphObject {
        data = typeof data === 'object' ? data : {};
        let result = new GraphObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCreateCards"] = this.totalCreateCards;
        data["totalSwitchCards"] = this.totalSwitchCards;
        data["totalKidClubs"] = this.totalKidClubs;
        data["totalOther"] = this.totalOther;
        return data; 
    }
}

export interface IGraphObject {
    totalCreateCards?: number;
    totalSwitchCards?: number;
    totalKidClubs?: number;
    totalOther?: number;
}

export class ReceptionGraphDto implements IReceptionGraphDto {
    receptionDateObj?: DateObject | undefined;
    receptionDate?: Date;
    isDisplayMonth?: boolean;
    totalCreateCards?: number;
    totalSwitchCards?: number;
    totalOther?: number;
    totalKidClubs?: number;

    constructor(data?: IReceptionGraphDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.receptionDateObj = _data["receptionDateObj"] ? DateObject.fromJS(_data["receptionDateObj"]) : <any>undefined;
            this.receptionDate = _data["receptionDate"] ? new Date(_data["receptionDate"].toString()) : <any>undefined;
            this.isDisplayMonth = _data["isDisplayMonth"];
            this.totalCreateCards = _data["totalCreateCards"];
            this.totalSwitchCards = _data["totalSwitchCards"];
            this.totalOther = _data["totalOther"];
            this.totalKidClubs = _data["totalKidClubs"];
        }
    }

    static fromJS(data: any): ReceptionGraphDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReceptionGraphDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receptionDateObj"] = this.receptionDateObj ? this.receptionDateObj.toJSON() : <any>undefined;
        data["receptionDate"] = this.receptionDate ? this.receptionDate.toISOString() : <any>undefined;
        data["isDisplayMonth"] = this.isDisplayMonth;
        data["totalCreateCards"] = this.totalCreateCards;
        data["totalSwitchCards"] = this.totalSwitchCards;
        data["totalOther"] = this.totalOther;
        data["totalKidClubs"] = this.totalKidClubs;
        return data; 
    }
}

export interface IReceptionGraphDto {
    receptionDateObj?: DateObject | undefined;
    receptionDate?: Date;
    isDisplayMonth?: boolean;
    totalCreateCards?: number;
    totalSwitchCards?: number;
    totalOther?: number;
    totalKidClubs?: number;
}

export class DateObject implements IDateObject {
    year?: number;
    month?: number;
    day?: number;

    constructor(data?: IDateObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.year = _data["year"];
            this.month = _data["month"];
            this.day = _data["day"];
        }
    }

    static fromJS(data: any): DateObject {
        data = typeof data === 'object' ? data : {};
        let result = new DateObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["year"] = this.year;
        data["month"] = this.month;
        data["day"] = this.day;
        return data; 
    }
}

export interface IDateObject {
    year?: number;
    month?: number;
    day?: number;
}

export class PaginatedListOfReceptionDetailDto implements IPaginatedListOfReceptionDetailDto {
    items?: ReceptionDetailDto[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfReceptionDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ReceptionDetailDto.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfReceptionDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfReceptionDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data; 
    }
}

export interface IPaginatedListOfReceptionDetailDto {
    items?: ReceptionDetailDto[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ReceptionDetailDto implements IReceptionDetailDto {
    no?: number;
    receptionDateObj?: DateObject | undefined;
    receptionDate?: Date;
    totalCreateCards?: number;
    totalSwitchCards?: number;
    totalReissuedCards?: number;
    totalChangeCards?: number;
    totalDiscardCards?: number;
    totalPointMigration?: number;
    totalKidClubs?: number;

    constructor(data?: IReceptionDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.no = _data["no"];
            this.receptionDateObj = _data["receptionDateObj"] ? DateObject.fromJS(_data["receptionDateObj"]) : <any>undefined;
            this.receptionDate = _data["receptionDate"] ? new Date(_data["receptionDate"].toString()) : <any>undefined;
            this.totalCreateCards = _data["totalCreateCards"];
            this.totalSwitchCards = _data["totalSwitchCards"];
            this.totalReissuedCards = _data["totalReissuedCards"];
            this.totalChangeCards = _data["totalChangeCards"];
            this.totalDiscardCards = _data["totalDiscardCards"];
            this.totalPointMigration = _data["totalPointMigration"];
            this.totalKidClubs = _data["totalKidClubs"];
        }
    }

    static fromJS(data: any): ReceptionDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReceptionDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["no"] = this.no;
        data["receptionDateObj"] = this.receptionDateObj ? this.receptionDateObj.toJSON() : <any>undefined;
        data["receptionDate"] = this.receptionDate ? this.receptionDate.toISOString() : <any>undefined;
        data["totalCreateCards"] = this.totalCreateCards;
        data["totalSwitchCards"] = this.totalSwitchCards;
        data["totalReissuedCards"] = this.totalReissuedCards;
        data["totalChangeCards"] = this.totalChangeCards;
        data["totalDiscardCards"] = this.totalDiscardCards;
        data["totalPointMigration"] = this.totalPointMigration;
        data["totalKidClubs"] = this.totalKidClubs;
        return data; 
    }
}

export interface IReceptionDetailDto {
    no?: number;
    receptionDateObj?: DateObject | undefined;
    receptionDate?: Date;
    totalCreateCards?: number;
    totalSwitchCards?: number;
    totalReissuedCards?: number;
    totalChangeCards?: number;
    totalDiscardCards?: number;
    totalPointMigration?: number;
    totalKidClubs?: number;
}

export class PaginatedListOfRequestsReceiptedDto implements IPaginatedListOfRequestsReceiptedDto {
    items?: RequestsReceiptedDto[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfRequestsReceiptedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(RequestsReceiptedDto.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfRequestsReceiptedDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfRequestsReceiptedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data; 
    }
}

export interface IPaginatedListOfRequestsReceiptedDto {
    items?: RequestsReceiptedDto[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class RequestsReceiptedDto implements IRequestsReceiptedDto {
    id?: number;
    index?: number;
    receiptedDatetime?: Date;
    requestTypeName?: string | undefined;
    memberNo?: string | undefined;
    memberName?: string | undefined;
    store?: string | undefined;
    normalizedStoreName?: string | undefined;
    company?: string | undefined;
    normalizedCompanyName?: string | undefined;
    picName?: string | undefined;
    remark?: string | undefined;

    constructor(data?: IRequestsReceiptedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.index = _data["index"];
            this.receiptedDatetime = _data["receiptedDatetime"] ? new Date(_data["receiptedDatetime"].toString()) : <any>undefined;
            this.requestTypeName = _data["requestTypeName"];
            this.memberNo = _data["memberNo"];
            this.memberName = _data["memberName"];
            this.store = _data["store"];
            this.normalizedStoreName = _data["normalizedStoreName"];
            this.company = _data["company"];
            this.normalizedCompanyName = _data["normalizedCompanyName"];
            this.picName = _data["picName"];
            this.remark = _data["remark"];
        }
    }

    static fromJS(data: any): RequestsReceiptedDto {
        data = typeof data === 'object' ? data : {};
        let result = new RequestsReceiptedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["index"] = this.index;
        data["receiptedDatetime"] = this.receiptedDatetime ? this.receiptedDatetime.toISOString() : <any>undefined;
        data["requestTypeName"] = this.requestTypeName;
        data["memberNo"] = this.memberNo;
        data["memberName"] = this.memberName;
        data["store"] = this.store;
        data["normalizedStoreName"] = this.normalizedStoreName;
        data["company"] = this.company;
        data["normalizedCompanyName"] = this.normalizedCompanyName;
        data["picName"] = this.picName;
        data["remark"] = this.remark;
        return data; 
    }
}

export interface IRequestsReceiptedDto {
    id?: number;
    index?: number;
    receiptedDatetime?: Date;
    requestTypeName?: string | undefined;
    memberNo?: string | undefined;
    memberName?: string | undefined;
    store?: string | undefined;
    normalizedStoreName?: string | undefined;
    company?: string | undefined;
    normalizedCompanyName?: string | undefined;
    picName?: string | undefined;
    remark?: string | undefined;
}

export class RequestsReceiptedDetailsDto implements IRequestsReceiptedDetailsDto {
    id?: number;
    requestCode?: string | undefined;
    storeId?: number | undefined;
    receiptedDatetime?: Date;
    updatedAt?: Date | undefined;
    requestType?: RequestType | undefined;
    device?: Device | undefined;
    member?: Member | undefined;
    store?: Store | undefined;

    constructor(data?: IRequestsReceiptedDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.requestCode = _data["requestCode"];
            this.storeId = _data["storeId"];
            this.receiptedDatetime = _data["receiptedDatetime"] ? new Date(_data["receiptedDatetime"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.requestType = _data["requestType"] ? RequestType.fromJS(_data["requestType"]) : <any>undefined;
            this.device = _data["device"] ? Device.fromJS(_data["device"]) : <any>undefined;
            this.member = _data["member"] ? Member.fromJS(_data["member"]) : <any>undefined;
            this.store = _data["store"] ? Store.fromJS(_data["store"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RequestsReceiptedDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new RequestsReceiptedDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["requestCode"] = this.requestCode;
        data["storeId"] = this.storeId;
        data["receiptedDatetime"] = this.receiptedDatetime ? this.receiptedDatetime.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["requestType"] = this.requestType ? this.requestType.toJSON() : <any>undefined;
        data["device"] = this.device ? this.device.toJSON() : <any>undefined;
        data["member"] = this.member ? this.member.toJSON() : <any>undefined;
        data["store"] = this.store ? this.store.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IRequestsReceiptedDetailsDto {
    id?: number;
    requestCode?: string | undefined;
    storeId?: number | undefined;
    receiptedDatetime?: Date;
    updatedAt?: Date | undefined;
    requestType?: RequestType | undefined;
    device?: Device | undefined;
    member?: Member | undefined;
    store?: Store | undefined;
}

export class UpdateHistoryCommand implements IUpdateHistoryCommand {
    id?: number;
    picStoreId?: number | undefined;
    remark?: string | undefined;
    updatedAt?: Date | undefined;
    memberInfo?: MemberInfoDto | undefined;

    constructor(data?: IUpdateHistoryCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.picStoreId = _data["picStoreId"];
            this.remark = _data["remark"];
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.memberInfo = _data["memberInfo"] ? MemberInfoDto.fromJS(_data["memberInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateHistoryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateHistoryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["picStoreId"] = this.picStoreId;
        data["remark"] = this.remark;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["memberInfo"] = this.memberInfo ? this.memberInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IUpdateHistoryCommand {
    id?: number;
    picStoreId?: number | undefined;
    remark?: string | undefined;
    updatedAt?: Date | undefined;
    memberInfo?: MemberInfoDto | undefined;
}

export class PaginatedListOfStoreDto implements IPaginatedListOfStoreDto {
    items?: StoreDto[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfStoreDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StoreDto.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfStoreDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfStoreDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data; 
    }
}

export interface IPaginatedListOfStoreDto {
    items?: StoreDto[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class StoresVm implements IStoresVm {
    lists?: FlatStoreDto[] | undefined;

    constructor(data?: IStoresVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["lists"])) {
                this.lists = [] as any;
                for (let item of _data["lists"])
                    this.lists!.push(FlatStoreDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StoresVm {
        data = typeof data === 'object' ? data : {};
        let result = new StoresVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.lists)) {
            data["lists"] = [];
            for (let item of this.lists)
                data["lists"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IStoresVm {
    lists?: FlatStoreDto[] | undefined;
}

export class CreateStoreCommand implements ICreateStoreCommand {
    storeCode?: string | undefined;
    storeName?: string | undefined;
    normalizedStoreName?: string | undefined;
    order?: number;
    isActive?: boolean;
    companyCode?: string | undefined;

    constructor(data?: ICreateStoreCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.storeCode = _data["storeCode"];
            this.storeName = _data["storeName"];
            this.normalizedStoreName = _data["normalizedStoreName"];
            this.order = _data["order"];
            this.isActive = _data["isActive"];
            this.companyCode = _data["companyCode"];
        }
    }

    static fromJS(data: any): CreateStoreCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateStoreCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["storeCode"] = this.storeCode;
        data["storeName"] = this.storeName;
        data["normalizedStoreName"] = this.normalizedStoreName;
        data["order"] = this.order;
        data["isActive"] = this.isActive;
        data["companyCode"] = this.companyCode;
        return data; 
    }
}

export interface ICreateStoreCommand {
    storeCode?: string | undefined;
    storeName?: string | undefined;
    normalizedStoreName?: string | undefined;
    order?: number;
    isActive?: boolean;
    companyCode?: string | undefined;
}

export class UpdateStoreCommand implements IUpdateStoreCommand {
    id?: number;
    storeCode?: string | undefined;
    storeName?: string | undefined;
    normalizedStoreName?: string | undefined;
    order?: number;
    isActive?: boolean;
    updatedAt?: Date | undefined;

    constructor(data?: IUpdateStoreCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.storeCode = _data["storeCode"];
            this.storeName = _data["storeName"];
            this.normalizedStoreName = _data["normalizedStoreName"];
            this.order = _data["order"];
            this.isActive = _data["isActive"];
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateStoreCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateStoreCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["storeCode"] = this.storeCode;
        data["storeName"] = this.storeName;
        data["normalizedStoreName"] = this.normalizedStoreName;
        data["order"] = this.order;
        data["isActive"] = this.isActive;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IUpdateStoreCommand {
    id?: number;
    storeCode?: string | undefined;
    storeName?: string | undefined;
    normalizedStoreName?: string | undefined;
    order?: number;
    isActive?: boolean;
    updatedAt?: Date | undefined;
}

export class DeleteStoreCommand implements IDeleteStoreCommand {
    id?: number;
    updatedAt?: Date | undefined;

    constructor(data?: IDeleteStoreCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DeleteStoreCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteStoreCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IDeleteStoreCommand {
    id?: number;
    updatedAt?: Date | undefined;
}

export class StoreByUserDto implements IStoreByUserDto {
    id?: number;
    storeCode?: string | undefined;
    storeName?: string | undefined;
    companyId?: number;
    normalizedStoreName?: string | undefined;
    lat?: number;
    long?: number;

    constructor(data?: IStoreByUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.storeCode = _data["storeCode"];
            this.storeName = _data["storeName"];
            this.companyId = _data["companyId"];
            this.normalizedStoreName = _data["normalizedStoreName"];
            this.lat = _data["lat"];
            this.long = _data["long"];
        }
    }

    static fromJS(data: any): StoreByUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new StoreByUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["storeCode"] = this.storeCode;
        data["storeName"] = this.storeName;
        data["companyId"] = this.companyId;
        data["normalizedStoreName"] = this.normalizedStoreName;
        data["lat"] = this.lat;
        data["long"] = this.long;
        return data; 
    }
}

export interface IStoreByUserDto {
    id?: number;
    storeCode?: string | undefined;
    storeName?: string | undefined;
    companyId?: number;
    normalizedStoreName?: string | undefined;
    lat?: number;
    long?: number;
}

export class CreateUserResultDto implements ICreateUserResultDto {
    isSuccess?: boolean;
    messageCode?: string | undefined;

    constructor(data?: ICreateUserResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.messageCode = _data["messageCode"];
        }
    }

    static fromJS(data: any): CreateUserResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["messageCode"] = this.messageCode;
        return data; 
    }
}

export interface ICreateUserResultDto {
    isSuccess?: boolean;
    messageCode?: string | undefined;
}

export class CreateUserCommand implements ICreateUserCommand {
    companyCode?: string | undefined;
    storeCode?: string | undefined;
    permission?: string | undefined;
    userName?: string | undefined;
    fullName?: string | undefined;
    password?: string | undefined;

    constructor(data?: ICreateUserCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.companyCode = _data["companyCode"];
            this.storeCode = _data["storeCode"];
            this.permission = _data["permission"];
            this.userName = _data["userName"];
            this.fullName = _data["fullName"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): CreateUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyCode"] = this.companyCode;
        data["storeCode"] = this.storeCode;
        data["permission"] = this.permission;
        data["userName"] = this.userName;
        data["fullName"] = this.fullName;
        data["password"] = this.password;
        return data; 
    }
}

export interface ICreateUserCommand {
    companyCode?: string | undefined;
    storeCode?: string | undefined;
    permission?: string | undefined;
    userName?: string | undefined;
    fullName?: string | undefined;
    password?: string | undefined;
}

export class UpdateUserResultDto implements IUpdateUserResultDto {
    isSuccess?: boolean;
    messageCode?: string | undefined;

    constructor(data?: IUpdateUserResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.messageCode = _data["messageCode"];
        }
    }

    static fromJS(data: any): UpdateUserResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["messageCode"] = this.messageCode;
        return data; 
    }
}

export interface IUpdateUserResultDto {
    isSuccess?: boolean;
    messageCode?: string | undefined;
}

export class UpdateUserCommand implements IUpdateUserCommand {
    id?: string | undefined;
    companyCode?: string | undefined;
    storeCode?: string | undefined;
    permission?: string | undefined;
    userName?: string | undefined;
    fullName?: string | undefined;
    password?: string | undefined;
    oldUserName?: string | undefined;
    oldCompanyCode?: string | undefined;
    oldStoreCode?: string | undefined;

    constructor(data?: IUpdateUserCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyCode = _data["companyCode"];
            this.storeCode = _data["storeCode"];
            this.permission = _data["permission"];
            this.userName = _data["userName"];
            this.fullName = _data["fullName"];
            this.password = _data["password"];
            this.oldUserName = _data["oldUserName"];
            this.oldCompanyCode = _data["oldCompanyCode"];
            this.oldStoreCode = _data["oldStoreCode"];
        }
    }

    static fromJS(data: any): UpdateUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyCode"] = this.companyCode;
        data["storeCode"] = this.storeCode;
        data["permission"] = this.permission;
        data["userName"] = this.userName;
        data["fullName"] = this.fullName;
        data["password"] = this.password;
        data["oldUserName"] = this.oldUserName;
        data["oldCompanyCode"] = this.oldCompanyCode;
        data["oldStoreCode"] = this.oldStoreCode;
        return data; 
    }
}

export interface IUpdateUserCommand {
    id?: string | undefined;
    companyCode?: string | undefined;
    storeCode?: string | undefined;
    permission?: string | undefined;
    userName?: string | undefined;
    fullName?: string | undefined;
    password?: string | undefined;
    oldUserName?: string | undefined;
    oldCompanyCode?: string | undefined;
    oldStoreCode?: string | undefined;
}

export class PaginatedListOfUserDto implements IPaginatedListOfUserDto {
    items?: UserDto[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPaginatedListOfUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserDto.fromJS(item));
            }
            this.pageIndex = _data["pageIndex"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PaginatedListOfUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedListOfUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageIndex"] = this.pageIndex;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data; 
    }
}

export interface IPaginatedListOfUserDto {
    items?: UserDto[] | undefined;
    pageIndex?: number;
    totalPages?: number;
    totalCount?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class UserDto implements IUserDto {
    userName?: string | undefined;
    permission?: string | undefined;
    companyName?: string | undefined;
    normalizedCompanyName?: string | undefined;
    companyCode?: string | undefined;
    companyId?: number;
    storeName?: string | undefined;
    normalizedStoreName?: string | undefined;
    storeCode?: string | undefined;
    fullName?: string | undefined;
    createdAt?: Date;
    id?: string | undefined;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.permission = _data["permission"];
            this.companyName = _data["companyName"];
            this.normalizedCompanyName = _data["normalizedCompanyName"];
            this.companyCode = _data["companyCode"];
            this.companyId = _data["companyId"];
            this.storeName = _data["storeName"];
            this.normalizedStoreName = _data["normalizedStoreName"];
            this.storeCode = _data["storeCode"];
            this.fullName = _data["fullName"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["permission"] = this.permission;
        data["companyName"] = this.companyName;
        data["normalizedCompanyName"] = this.normalizedCompanyName;
        data["companyCode"] = this.companyCode;
        data["companyId"] = this.companyId;
        data["storeName"] = this.storeName;
        data["normalizedStoreName"] = this.normalizedStoreName;
        data["storeCode"] = this.storeCode;
        data["fullName"] = this.fullName;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserDto {
    userName?: string | undefined;
    permission?: string | undefined;
    companyName?: string | undefined;
    normalizedCompanyName?: string | undefined;
    companyCode?: string | undefined;
    companyId?: number;
    storeName?: string | undefined;
    normalizedStoreName?: string | undefined;
    storeCode?: string | undefined;
    fullName?: string | undefined;
    createdAt?: Date;
    id?: string | undefined;
}

export class DeleteUserResultDto implements IDeleteUserResultDto {
    isSuccess?: boolean;
    messageCode?: string | undefined;

    constructor(data?: IDeleteUserResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.messageCode = _data["messageCode"];
        }
    }

    static fromJS(data: any): DeleteUserResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteUserResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["messageCode"] = this.messageCode;
        return data; 
    }
}

export interface IDeleteUserResultDto {
    isSuccess?: boolean;
    messageCode?: string | undefined;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}